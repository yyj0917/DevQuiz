[
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 1,
    "question": "해시 테이블(Hash Table)의 평균 시간복잡도로 올바른 것은?",
    "options": [
      "검색 O(n), 삽입 O(n), 삭제 O(n)",
      "검색 O(log n), 삽입 O(log n), 삭제 O(log n)",
      "검색 O(1), 삽입 O(1), 삭제 O(1)",
      "검색 O(1), 삽입 O(n), 삭제 O(n)"
    ],
    "answer": "2",
    "explanation": "해시 테이블은 키를 해시 함수로 인덱스로 변환하여 평균 O(1)에 접근합니다. 단, 해시 충돌이 많으면 최악의 경우 O(n)이 될 수 있습니다. 좋은 해시 함수와 적절한 테이블 크기로 충돌을 최소화하는 것이 중요합니다. JavaScript Object, Python dict, Java HashMap이 해시 테이블 기반입니다.",
    "tags": ["해시테이블", "시간복잡도", "O(1)"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "해시 충돌(Hash Collision)이 발생하는 경우는?",
    "options": [
      "해시 테이블의 크기가 너무 클 때",
      "서로 다른 키가 동일한 해시 값을 가질 때",
      "해시 함수의 계산 시간이 오래 걸릴 때",
      "키가 정수가 아닐 때"
    ],
    "answer": "1",
    "explanation": "해시 충돌은 서로 다른 키 k1, k2에 대해 hash(k1) == hash(k2)인 경우 발생합니다. 비둘기집 원리에 의해 키의 수가 테이블 크기보다 많으면 충돌이 불가피합니다. 충돌 해결 방법으로 체이닝(Chaining), 개방 주소법(Open Addressing) 등이 있습니다.",
    "tags": ["해시충돌", "비둘기집원리", "해시함수"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "해시 충돌 해결 방법 중 체이닝(Chaining)에 대한 설명으로 올바른 것은?",
    "options": [
      "충돌 시 다음 빈 슬롯을 찾아 저장한다",
      "충돌 시 해당 버킷에 연결 리스트로 여러 요소를 저장한다",
      "충돌 시 해시 함수를 다시 계산한다",
      "충돌 시 기존 요소를 덮어쓴다"
    ],
    "answer": "1",
    "explanation": "체이닝은 각 버킷을 연결 리스트(또는 다른 자료구조)로 만들어 충돌하는 요소들을 같은 버킷에 저장합니다. 구현이 간단하고 삭제가 쉽지만, 추가 메모리가 필요합니다. Java HashMap은 체이닝을 사용하며, 충돌이 많으면 연결 리스트를 트리로 변환하여 O(log n)을 보장합니다.",
    "tags": ["체이닝", "해시충돌", "연결리스트"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "해시 충돌 해결 방법 중 개방 주소법(Open Addressing)의 선형 탐사(Linear Probing)에 대한 설명으로 올바른 것은?",
    "options": [
      "충돌 시 연결 리스트에 추가한다",
      "충돌 시 다음 슬롯을 순차적으로 탐색하여 빈 곳에 저장한다",
      "충돌 시 제곱 간격으로 탐색한다",
      "충돌 시 다른 해시 함수를 사용한다"
    ],
    "answer": "1",
    "explanation": "선형 탐사는 충돌 시 hash(key)+1, hash(key)+2, ... 순서로 빈 슬롯을 찾습니다. 추가 메모리 없이 테이블 내에서 해결하지만, 연속된 슬롯이 채워지는 클러스터링(Clustering) 문제가 발생할 수 있습니다. 이차 탐사(Quadratic Probing)는 제곱 간격으로, 이중 해싱(Double Hashing)은 두 번째 해시 함수로 간격을 결정합니다.",
    "tags": ["개방주소법", "선형탐사", "클러스터링"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "해시 테이블의 적재율(Load Factor)이 높아지면 발생하는 문제와 해결책으로 올바른 것은?",
    "options": [
      "메모리 사용량이 감소하므로 더 큰 테이블로 교체한다",
      "충돌이 증가하고 성능이 저하되므로 리해싱(Rehashing)을 수행한다",
      "해시 함수의 계산이 빨라지므로 그대로 유지한다",
      "데이터 손실이 발생하므로 백업을 수행한다"
    ],
    "answer": "1",
    "explanation": "적재율(Load Factor) = 저장된 요소 수 / 테이블 크기입니다. 적재율이 높으면 충돌 확률이 증가하여 O(1) 성능이 보장되지 않습니다. 일반적으로 적재율이 임계값(예: 0.75)을 넘으면 테이블 크기를 늘리고 모든 요소를 다시 해싱(Rehashing)합니다. 이 과정은 O(n)이지만 분할 상환으로 평균 O(1)을 유지합니다.",
    "tags": ["적재율", "리해싱", "성능최적화"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "좋은 해시 함수의 조건으로 올바르지 않은 것은?",
    "options": [
      "계산이 빠르고 효율적이어야 한다",
      "해시 값이 테이블 전체에 균등하게 분포해야 한다",
      "동일한 입력에 대해 항상 동일한 출력을 반환해야 한다",
      "서로 다른 입력에 대해 항상 서로 다른 출력을 반환해야 한다"
    ],
    "answer": "3",
    "explanation": "해시 함수는 무한한 입력을 유한한 출력 범위로 매핑하므로 충돌은 불가피합니다. 따라서 '항상 다른 출력'은 불가능합니다. 좋은 해시 함수는: (1) 결정적(동일 입력→동일 출력) (2) 빠른 계산 (3) 균등 분포 (4) 눈사태 효과(입력 일부 변경 시 출력이 크게 변화)를 만족해야 합니다.",
    "tags": ["해시함수", "균등분포", "결정적"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 1,
    "question": "해시 테이블에서 키(Key)는 중복될 수 없지만, 값(Value)은 중복될 수 있다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 해시 테이블은 키-값 쌍을 저장하며, 각 키는 고유해야 합니다. 같은 키로 다시 삽입하면 기존 값을 덮어씁니다. 하지만 서로 다른 키가 같은 값을 가질 수 있습니다. 예: {'apple': 1, 'banana': 1}에서 값 1이 중복됩니다. JavaScript Object, Python dict 등이 이 규칙을 따릅니다.",
    "tags": ["해시테이블", "키값쌍", "중복"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "해시 테이블은 데이터가 정렬된 상태로 저장되므로 범위 검색에 효율적이다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. 해시 테이블은 해시 값에 따라 저장되어 순서가 없습니다. 따라서 범위 검색(예: 10~20 사이의 키)이나 정렬된 순회에 비효율적입니다. 범위 검색이 필요하면 이진 탐색 트리(BST)나 B-트리가 적합합니다. 단, LinkedHashMap처럼 삽입 순서를 유지하는 변형도 있습니다.",
    "tags": ["해시테이블", "정렬", "범위검색"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "해시 테이블의 최악 시간복잡도는 모든 키가 같은 버킷에 충돌할 때 O(n)이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 모든 키가 동일한 해시 값을 가지면 한 버킷에 n개가 저장됩니다. 체이닝의 경우 연결 리스트 탐색에 O(n), 개방 주소법도 연속 탐사에 O(n)이 걸립니다. 이를 방지하려면 좋은 해시 함수, 적절한 테이블 크기, 리해싱이 필요합니다. Java 8+의 HashMap은 체인 길이가 8을 넘으면 트리로 변환하여 O(log n)을 보장합니다.",
    "tags": ["해시테이블", "최악시간복잡도", "충돌"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "blank",
    "difficulty": 1,
    "question": "해시 테이블에서 키를 인덱스로 변환하는 함수를 _____ 함수라고 한다.",
    "options": null,
    "answer": "해시",
    "explanation": "해시 함수(Hash Function)는 임의 크기의 데이터를 고정 크기의 해시 값으로 변환합니다. 해시 테이블에서는 이 해시 값을 테이블 크기로 나눈 나머지를 인덱스로 사용합니다. 좋은 해시 함수는 빠르고, 균등하게 분포하며, 결정적(같은 입력→같은 출력)이어야 합니다. 암호화에서도 해시 함수를 사용합니다(SHA, MD5 등).",
    "tags": ["해시함수", "해시테이블", "기본개념"],
    "source": null
  }
]

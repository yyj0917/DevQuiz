[
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 1,
    "question": "배열(Array)의 특징으로 올바른 것은?",
    "options": [
      "삽입과 삭제가 O(1)로 매우 빠르다",
      "인덱스를 통한 임의 접근(Random Access)이 O(1)로 가능하다",
      "크기를 동적으로 자유롭게 변경할 수 있다",
      "메모리에 불연속적으로 저장된다"
    ],
    "answer": "1",
    "explanation": "배열은 메모리에 연속적으로 저장되어 인덱스로 O(1) 접근이 가능합니다. 하지만 중간 삽입/삭제 시 요소들을 이동해야 해서 O(n)이 걸리고, 크기가 고정되어 있습니다(정적 배열 기준). 동적 배열(ArrayList, Vector)도 내부적으로는 배열이며, 크기 초과 시 새 배열을 할당하고 복사합니다.",
    "tags": ["배열", "RandomAccess", "시간복잡도"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "연결 리스트(Linked List)가 배열보다 유리한 경우는?",
    "options": [
      "특정 인덱스의 요소에 빠르게 접근해야 할 때",
      "데이터의 삽입과 삭제가 빈번하게 발생할 때",
      "메모리 사용량을 최소화해야 할 때",
      "캐시 지역성(Cache Locality)이 중요할 때"
    ],
    "answer": "1",
    "explanation": "연결 리스트는 노드의 포인터만 변경하면 되므로 삽입/삭제가 O(1)입니다(위치를 알고 있을 때). 반면 배열은 요소 이동이 필요해 O(n)입니다. 단, 연결 리스트는 포인터 저장 공간이 추가로 필요하고, 메모리가 불연속적이라 캐시 효율이 낮습니다. 인덱스 접근은 O(n)으로 배열보다 느립니다.",
    "tags": ["연결리스트", "배열비교", "삽입삭제"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "단일 연결 리스트(Singly Linked List)에서 마지막 노드를 삭제하는 시간복잡도는?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "answer": "1",
    "explanation": "단일 연결 리스트에서 마지막 노드를 삭제하려면 마지막 노드의 이전 노드를 찾아야 합니다. 단일 연결 리스트는 다음 노드만 가리키므로 처음부터 순회해야 하여 O(n)이 걸립니다. 이중 연결 리스트는 이전 노드 포인터가 있어 tail에서 바로 접근 가능하지만, tail 포인터를 갱신하려면 여전히 이전 노드가 필요합니다.",
    "tags": ["단일연결리스트", "삭제", "시간복잡도"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "이중 연결 리스트(Doubly Linked List)의 특징으로 올바르지 않은 것은?",
    "options": [
      "각 노드가 이전 노드와 다음 노드를 모두 가리킨다",
      "양방향 탐색이 가능하다",
      "단일 연결 리스트보다 메모리를 적게 사용한다",
      "특정 노드의 삭제가 O(1)로 가능하다"
    ],
    "answer": "2",
    "explanation": "이중 연결 리스트는 prev, next 두 개의 포인터를 저장하므로 단일 연결 리스트보다 메모리를 더 사용합니다. 장점은 양방향 탐색이 가능하고, 특정 노드의 삭제 시 이전 노드를 찾기 위해 순회할 필요 없이 바로 접근할 수 있어 O(1)에 삭제 가능합니다. 브라우저 히스토리, LRU 캐시 구현에 자주 사용됩니다.",
    "tags": ["이중연결리스트", "메모리", "양방향탐색"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "동적 배열(Dynamic Array)에서 배열이 가득 찼을 때 크기를 2배로 늘리는 전략을 사용한다면, n개의 요소를 순차적으로 삽입할 때의 평균(Amortized) 시간복잡도는?",
    "options": [
      "O(n²)",
      "O(n log n)",
      "O(n)",
      "O(1)"
    ],
    "answer": "2",
    "explanation": "개별 삽입은 최악의 경우 O(n)이지만(재할당 시), 2배씩 늘리면 재할당 횟수가 로그 스케일로 감소합니다. n개 삽입 시 총 복사 비용은 1+2+4+...+n ≈ 2n으로, 전체 O(n)입니다. 따라서 삽입당 평균(Amortized) O(1)입니다. 이를 분할 상환 분석이라 하며, ArrayList, JavaScript Array 등이 이 방식을 사용합니다.",
    "tags": ["동적배열", "Amortized", "분할상환분석"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "원형 연결 리스트(Circular Linked List)의 특징으로 올바른 것은?",
    "options": [
      "마지막 노드가 null을 가리킨다",
      "마지막 노드가 첫 번째 노드를 가리켜 순환 구조를 이룬다",
      "인덱스를 통한 접근이 O(1)이다",
      "이중 연결 리스트보다 메모리를 더 사용한다"
    ],
    "answer": "1",
    "explanation": "원형 연결 리스트는 마지막 노드의 next가 첫 번째 노드를 가리켜 순환합니다. 모든 노드에서 전체 리스트 순회가 가능하고, 끝을 체크하는 대신 시작점 도달 여부로 종료를 판단합니다. 라운드 로빈 스케줄링, 음악 플레이어 반복 재생 등에 활용됩니다. 단일/이중 모두 원형으로 만들 수 있습니다.",
    "tags": ["원형연결리스트", "순환구조", "활용사례"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 1,
    "question": "배열에서 특정 값을 검색하는 최악의 시간복잡도는 O(n)이다.",
    "options": null,
    "answer": "true",
    "explanation": "정렬되지 않은 배열에서 특정 값을 찾으려면 처음부터 끝까지 순차 탐색해야 하므로 최악의 경우 O(n)입니다. 정렬된 배열이라면 이진 탐색으로 O(log n)에 검색 가능합니다. 인덱스로 접근하는 것은 O(1)이지만, 값으로 검색하는 것은 다릅니다.",
    "tags": ["배열", "검색", "시간복잡도"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "연결 리스트는 메모리에 연속적으로 저장되므로 캐시 효율이 높다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. 연결 리스트는 각 노드가 메모리의 임의 위치에 흩어져 있고 포인터로 연결됩니다. 따라서 메모리에 불연속적으로 저장되어 캐시 지역성(Cache Locality)이 낮습니다. 배열은 연속 메모리에 저장되어 캐시 효율이 높고, 이는 실제 성능에서 중요한 차이를 만듭니다.",
    "tags": ["연결리스트", "캐시지역성", "메모리구조"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "연결 리스트의 중간에 노드를 삽입하려면 삽입 위치까지 순회한 후 포인터만 변경하면 되므로, 순회 시간을 제외한 순수 삽입 연산은 O(1)이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 삽입 위치의 노드를 이미 알고 있다면, 새 노드 생성과 포인터 재설정만 필요하므로 O(1)입니다. 하지만 위치를 모른다면 탐색에 O(n)이 필요합니다. 이 때문에 '연결 리스트 삽입은 O(1)'이라고 할 때는 위치를 알고 있다는 전제가 있습니다. 배열은 위치를 알아도 요소 이동에 O(n)이 필요합니다.",
    "tags": ["연결리스트", "삽입", "포인터"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "blank",
    "difficulty": 1,
    "question": "연결 리스트에서 각 요소를 저장하는 단위를 _____라고 하며, 데이터와 다음 요소를 가리키는 포인터로 구성된다.",
    "options": null,
    "answer": "노드",
    "explanation": "노드(Node)는 연결 리스트의 기본 단위로, 데이터 필드와 링크(포인터) 필드로 구성됩니다. 단일 연결 리스트의 노드는 next 포인터 하나, 이중 연결 리스트의 노드는 prev, next 두 개의 포인터를 갖습니다. 트리, 그래프 등 다른 자료구조에서도 노드라는 용어를 사용합니다.",
    "tags": ["노드", "연결리스트", "기본개념"],
    "source": null
  }
]

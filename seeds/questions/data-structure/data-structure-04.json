[
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 1,
    "question": "이진 트리(Binary Tree)의 정의로 올바른 것은?",
    "options": [
      "각 노드가 최대 3개의 자식을 가지는 트리",
      "각 노드가 최대 2개의 자식을 가지는 트리",
      "모든 노드가 정확히 2개의 자식을 가지는 트리",
      "높이가 2인 트리"
    ],
    "answer": "1",
    "explanation": "이진 트리는 각 노드가 최대 2개의 자식(왼쪽, 오른쪽)을 가지는 트리입니다. 0개, 1개, 2개 모두 가능합니다. 포화 이진 트리(Full Binary Tree)는 모든 노드가 0개 또는 2개의 자식을 가지고, 완전 이진 트리(Complete Binary Tree)는 마지막 레벨을 제외하고 모두 채워진 트리입니다.",
    "tags": ["이진트리", "정의", "자식노드"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "이진 탐색 트리(BST)의 특징으로 올바른 것은?",
    "options": [
      "왼쪽 서브트리의 모든 값 < 루트 < 오른쪽 서브트리의 모든 값",
      "왼쪽 자식 < 루트 < 오른쪽 자식 (손자 노드는 무관)",
      "항상 균형이 맞아 높이가 O(log n)이다",
      "삽입 순서대로 노드가 배치된다"
    ],
    "answer": "0",
    "explanation": "BST는 왼쪽 서브트리의 '모든' 값이 루트보다 작고, 오른쪽 서브트리의 '모든' 값이 루트보다 큽니다. 자식뿐 아니라 손자, 그 아래까지 모두 해당됩니다. BST는 삽입 순서에 따라 편향될 수 있어 높이가 O(n)이 될 수 있습니다. AVL, Red-Black 트리는 균형을 유지하여 O(log n)을 보장합니다.",
    "tags": ["BST", "이진탐색트리", "정렬속성"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "균형 잡힌 이진 탐색 트리(Balanced BST)에서 검색, 삽입, 삭제의 시간복잡도는?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ],
    "answer": "1",
    "explanation": "균형 BST는 높이가 O(log n)으로 유지되어 모든 연산이 O(log n)입니다. 루트에서 시작해 각 레벨에서 왼쪽/오른쪽을 선택하며 내려가므로 높이만큼 비교합니다. AVL 트리는 높이 차이를 1 이하로, Red-Black 트리는 색상 규칙으로 균형을 유지합니다. 편향된 BST는 최악 O(n)입니다.",
    "tags": ["균형BST", "시간복잡도", "AVL", "Red-Black"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 2,
    "question": "힙(Heap) 자료구조의 특징으로 올바른 것은?",
    "options": [
      "완전 이진 트리이며, 부모가 항상 자식보다 크거나(최대 힙) 작다(최소 힙)",
      "이진 탐색 트리처럼 왼쪽 < 부모 < 오른쪽 조건을 만족한다",
      "삽입과 삭제가 O(1)이다",
      "정렬된 순서로 요소가 저장된다"
    ],
    "answer": "0",
    "explanation": "힙은 완전 이진 트리로, 최대 힙은 부모 ≥ 자식, 최소 힙은 부모 ≤ 자식 조건을 만족합니다. 루트가 최대/최소값이므로 우선순위 큐 구현에 사용됩니다. BST와 달리 왼쪽/오른쪽 간 대소 관계는 없습니다. 삽입/삭제는 O(log n)이고, 배열로 효율적으로 구현할 수 있습니다.",
    "tags": ["힙", "완전이진트리", "우선순위큐"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "이진 트리의 중위 순회(In-order Traversal) 결과가 정렬된 순서로 출력되는 트리는?",
    "options": [
      "완전 이진 트리",
      "이진 탐색 트리(BST)",
      "힙",
      "AVL 트리가 아닌 일반 이진 트리"
    ],
    "answer": "1",
    "explanation": "BST의 중위 순회(왼쪽→루트→오른쪽)는 오름차순 정렬된 결과를 출력합니다. 왼쪽 서브트리의 모든 값 < 루트 < 오른쪽 서브트리이므로, 왼쪽을 먼저 방문하고 루트, 오른쪽 순으로 방문하면 정렬됩니다. AVL, Red-Black도 BST이므로 동일합니다. 힙은 부모-자식 관계만 있어 중위 순회가 정렬되지 않습니다.",
    "tags": ["중위순회", "BST", "트리순회"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "multiple",
    "difficulty": 3,
    "question": "최소 힙(Min Heap)에서 최솟값 삭제 후 힙 속성을 복구하는 과정으로 올바른 것은?",
    "options": [
      "루트를 삭제하고 왼쪽 자식을 루트로 올린다",
      "루트를 삭제하고 마지막 노드를 루트로 올린 후, 자식과 비교하며 아래로 내린다 (Heapify Down)",
      "루트를 삭제하고 전체 트리를 다시 구성한다",
      "가장 큰 값을 찾아 루트와 교환한다"
    ],
    "answer": "1",
    "explanation": "최솟값(루트)을 삭제하면: (1) 마지막 노드를 루트로 이동 (완전 이진 트리 유지) (2) 루트에서 시작해 자식 중 더 작은 값과 비교 (3) 부모가 더 크면 교환 (4) 힙 조건 만족할 때까지 반복. 이를 Heapify Down 또는 Sift Down이라 하며 O(log n)입니다. 삽입 시는 Heapify Up을 사용합니다.",
    "tags": ["힙", "삭제", "HeapifyDown"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 1,
    "question": "트리에서 루트 노드는 부모가 없고, 리프 노드는 자식이 없는 노드이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 루트(Root)는 트리의 최상위 노드로 부모가 없습니다. 리프(Leaf) 또는 단말 노드는 자식이 없는 노드입니다. 루트와 리프 사이의 노드를 내부 노드(Internal Node)라고 합니다. 트리의 높이는 루트에서 가장 깊은 리프까지의 경로 길이입니다.",
    "tags": ["트리", "루트", "리프"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "힙(Heap)은 배열로 구현할 때, 인덱스 i의 왼쪽 자식은 2i+1, 오른쪽 자식은 2i+2에 위치한다 (0-based index).",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 완전 이진 트리인 힙은 레벨 순서대로 배열에 저장할 수 있습니다. 0-based 인덱스에서: 왼쪽 자식 = 2i+1, 오른쪽 자식 = 2i+2, 부모 = (i-1)/2 (정수 나눗셈). 1-based면: 왼쪽 = 2i, 오른쪽 = 2i+1, 부모 = i/2. 포인터 없이 인덱스 계산만으로 탐색할 수 있어 메모리 효율적입니다.",
    "tags": ["힙", "배열구현", "인덱스계산"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "ox",
    "difficulty": 2,
    "question": "이진 탐색 트리(BST)에서 삭제할 노드가 두 개의 자식을 가지면, 중위 후속자(Inorder Successor) 또는 중위 선행자와 값을 교환한 후 삭제한다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 두 자식이 있는 노드 삭제 시, 중위 후속자(오른쪽 서브트리의 최솟값) 또는 중위 선행자(왼쪽 서브트리의 최댓값)로 대체합니다. 이 값은 자식이 0개 또는 1개이므로 간단히 삭제할 수 있습니다. 대체 후에도 BST 속성이 유지됩니다. 시간복잡도는 O(h)로, 균형 트리면 O(log n)입니다.",
    "tags": ["BST", "삭제", "중위후속자"],
    "source": null
  },
  {
    "category": "data-structure",
    "type": "blank",
    "difficulty": 1,
    "question": "이진 트리 순회 방법 중, 루트를 먼저 방문하고 왼쪽, 오른쪽 순으로 방문하는 것을 _____ 순회라고 한다.",
    "options": null,
    "answer": "전위",
    "explanation": "전위 순회(Pre-order): 루트 → 왼쪽 → 오른쪽. 중위 순회(In-order): 왼쪽 → 루트 → 오른쪽. 후위 순회(Post-order): 왼쪽 → 오른쪽 → 루트. 레벨 순회(Level-order)는 BFS로 레벨별로 방문합니다. 전위는 복사에, 중위는 BST 정렬에, 후위는 삭제나 수식 계산에 활용됩니다.",
    "tags": ["트리순회", "전위순회", "DFS"],
    "source": null
  }
]

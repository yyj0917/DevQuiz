[
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "관계형 데이터베이스에서 테이블의 각 행(Row)을 고유하게 식별하는 키는?",
    "options": [
      "Foreign Key",
      "Primary Key",
      "Candidate Key",
      "Composite Key"
    ],
    "answer": "1",
    "explanation": "Primary Key(기본키)는 테이블에서 각 행을 고유하게 식별하는 키입니다. NULL 값을 허용하지 않고 중복될 수 없습니다. Foreign Key는 다른 테이블의 기본키를 참조하는 키, Candidate Key는 기본키가 될 수 있는 후보키, Composite Key는 두 개 이상의 컬럼을 조합한 키입니다.",
    "tags": ["Primary Key", "기본키", "관계형DB"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "SQL에서 데이터를 조회할 때 사용하는 명령어는?",
    "options": [
      "INSERT",
      "UPDATE",
      "SELECT",
      "DELETE"
    ],
    "answer": "2",
    "explanation": "SELECT는 데이터를 조회하는 DML(Data Manipulation Language) 명령어입니다. INSERT는 데이터 삽입, UPDATE는 데이터 수정, DELETE는 데이터 삭제에 사용됩니다. SELECT문은 가장 기본적이면서도 가장 많이 사용되는 SQL 명령어입니다.",
    "tags": ["SELECT", "DML", "SQL기본"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "다음 중 DDL(Data Definition Language)에 해당하는 명령어는?",
    "options": [
      "SELECT",
      "INSERT",
      "CREATE",
      "COMMIT"
    ],
    "answer": "2",
    "explanation": "DDL은 데이터베이스 구조를 정의하는 언어로 CREATE, ALTER, DROP, TRUNCATE가 있습니다. SELECT, INSERT, UPDATE, DELETE는 DML, COMMIT, ROLLBACK은 TCL(Transaction Control Language)에 해당합니다.",
    "tags": ["DDL", "CREATE", "SQL분류"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 2,
    "question": "TRUNCATE 명령어는 DELETE와 달리 롤백(ROLLBACK)이 가능하다.",
    "options": null,
    "answer": "false",
    "explanation": "TRUNCATE는 DDL 명령어로 실행 즉시 AUTO COMMIT되어 롤백이 불가능합니다. 반면 DELETE는 DML 명령어로 트랜잭션 내에서 롤백이 가능합니다. TRUNCATE는 테이블의 모든 데이터를 빠르게 삭제하지만, WHERE 조건을 사용할 수 없고 롤백도 불가능합니다.",
    "tags": ["TRUNCATE", "DELETE", "DDL", "롤백"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "두 테이블을 조인할 때, 양쪽 테이블에 모두 존재하는 데이터만 조회하는 조인 방식은?",
    "options": [
      "LEFT OUTER JOIN",
      "RIGHT OUTER JOIN",
      "FULL OUTER JOIN",
      "INNER JOIN"
    ],
    "answer": "3",
    "explanation": "INNER JOIN은 두 테이블에서 조인 조건을 만족하는 행만 반환합니다. LEFT/RIGHT OUTER JOIN은 한쪽 테이블의 모든 행과 매칭되는 행을 반환하고, FULL OUTER JOIN은 양쪽 테이블의 모든 행을 반환합니다. 실무에서 가장 많이 사용되는 조인 방식입니다.",
    "tags": ["JOIN", "INNER JOIN", "테이블조인"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 2,
    "question": "다음 SQL 쿼리의 실행 결과로 올바른 것은?",
    "code_snippet": "SELECT COUNT(*), COUNT(column_a)\nFROM (\n  SELECT 1 AS column_a UNION ALL\n  SELECT NULL UNION ALL\n  SELECT 3\n) t;",
    "options": [
      "3, 3",
      "3, 2",
      "2, 2",
      "2, 3"
    ],
    "answer": "1",
    "explanation": "COUNT(*)는 NULL을 포함한 모든 행의 개수를 세므로 3을 반환합니다. COUNT(column_a)는 NULL을 제외한 값의 개수를 세므로 2를 반환합니다. 이는 SQL에서 집계 함수가 NULL을 처리하는 중요한 차이점입니다.",
    "tags": ["COUNT", "NULL", "집계함수"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 2,
    "question": "다음 SQL의 실행 결과는?",
    "code_snippet": "SELECT COALESCE(NULL, NULL, 'A', 'B', NULL);",
    "options": [
      "NULL",
      "A",
      "B",
      "에러 발생"
    ],
    "answer": "1",
    "explanation": "COALESCE 함수는 인자들 중 첫 번째로 NULL이 아닌 값을 반환합니다. 왼쪽부터 순서대로 확인하여 NULL, NULL을 건너뛰고 'A'가 첫 번째 NULL이 아닌 값이므로 'A'를 반환합니다. NULL 처리에 매우 유용한 함수입니다.",
    "tags": ["COALESCE", "NULL처리", "SQL함수"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 2,
    "question": "WHERE 절에서 NULL 값을 비교할 때 'column = NULL' 형태로 사용할 수 있다.",
    "options": null,
    "answer": "false",
    "explanation": "NULL은 '알 수 없는 값'을 의미하므로 일반적인 비교 연산자(=, <>, <, >)로 비교할 수 없습니다. NULL 비교는 반드시 IS NULL 또는 IS NOT NULL을 사용해야 합니다. 'column = NULL'은 항상 UNKNOWN을 반환하여 조건이 만족되지 않습니다.",
    "tags": ["NULL", "IS NULL", "WHERE절"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 3,
    "question": "다음 중 서브쿼리의 결과가 여러 행을 반환할 때 사용할 수 없는 연산자는?",
    "options": [
      "IN",
      "ANY",
      "ALL",
      "="
    ],
    "answer": "3",
    "explanation": "= 연산자는 단일 값과의 비교에만 사용할 수 있어 서브쿼리가 여러 행을 반환하면 에러가 발생합니다. IN은 여러 값 중 하나와 일치하는지, ANY는 여러 값 중 하나와 조건을 만족하는지, ALL은 모든 값과 조건을 만족하는지 확인합니다.",
    "tags": ["서브쿼리", "IN", "ANY", "ALL"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 3,
    "question": "다음 SQL의 실행 결과로 올바른 것은?",
    "code_snippet": "SELECT department, COUNT(*) as cnt\nFROM employees\nWHERE salary > 3000\nGROUP BY department\nHAVING COUNT(*) >= 2\nORDER BY cnt DESC;",
    "options": [
      "급여가 3000 초과인 직원이 있는 모든 부서",
      "급여가 3000 초과인 직원이 2명 이상인 부서만 내림차순",
      "전체 직원이 2명 이상인 부서 중 급여 3000 초과자",
      "에러 발생 - HAVING에서 별칭 사용 불가"
    ],
    "answer": "1",
    "explanation": "SQL 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY입니다. 먼저 급여 3000 초과 직원을 필터링하고, 부서별로 그룹화한 뒤, 그 결과가 2명 이상인 부서만 선택합니다. 대부분의 DBMS에서 HAVING절에서 별칭 사용이 가능합니다.",
    "tags": ["GROUP BY", "HAVING", "SQL실행순서"],
    "source": null
  }
]

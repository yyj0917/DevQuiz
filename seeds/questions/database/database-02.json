[
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "제1정규형(1NF)을 만족하기 위한 조건은?",
    "options": [
      "부분 함수 종속 제거",
      "이행 함수 종속 제거",
      "모든 속성이 원자값을 가져야 함",
      "결정자가 후보키여야 함"
    ],
    "answer": "2",
    "explanation": "제1정규형(1NF)은 테이블의 모든 속성이 원자값(더 이상 분해할 수 없는 값)을 가져야 합니다. 예를 들어 하나의 셀에 여러 전화번호가 쉼표로 구분되어 있다면 1NF를 위반합니다. 부분 함수 종속 제거는 2NF, 이행 함수 종속 제거는 3NF의 조건입니다.",
    "tags": ["정규화", "1NF", "원자값"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "제2정규형(2NF)을 만족하려면 제1정규형을 만족하면서 추가로 어떤 조건을 충족해야 하는가?",
    "options": [
      "이행적 함수 종속 제거",
      "부분 함수 종속 제거",
      "다치 종속 제거",
      "결정자가 후보키여야 함"
    ],
    "answer": "1",
    "explanation": "제2정규형(2NF)은 1NF를 만족하면서 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되어야 합니다. 즉, 부분 함수 종속(기본키의 일부에만 종속)을 제거해야 합니다. 복합키를 사용하는 테이블에서 주로 발생하는 문제입니다.",
    "tags": ["정규화", "2NF", "부분함수종속"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "제3정규형(3NF)을 만족하려면 제2정규형을 만족하면서 추가로 어떤 조건을 충족해야 하는가?",
    "options": [
      "부분 함수 종속 제거",
      "이행적 함수 종속 제거",
      "모든 속성이 원자값",
      "다치 종속 제거"
    ],
    "answer": "1",
    "explanation": "제3정규형(3NF)은 2NF를 만족하면서 이행적 함수 종속을 제거해야 합니다. 이행적 함수 종속이란 A→B, B→C일 때 A→C가 성립하는 경우입니다. 예: 학번→학과, 학과→학과사무실이면 학과사무실은 별도 테이블로 분리해야 합니다.",
    "tags": ["정규화", "3NF", "이행함수종속"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 2,
    "question": "BCNF(Boyce-Codd Normal Form)는 제3정규형보다 더 엄격한 조건을 가진다.",
    "options": null,
    "answer": "true",
    "explanation": "BCNF는 3NF의 강화된 버전으로, 모든 결정자가 후보키여야 합니다. 3NF를 만족하더라도 BCNF를 만족하지 않을 수 있습니다. BCNF는 3NF에서 발생할 수 있는 이상 현상을 추가로 제거합니다. 정규화 단계: 1NF → 2NF → 3NF → BCNF → 4NF → 5NF",
    "tags": ["정규화", "BCNF", "3NF"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "다음 중 참조 무결성 제약조건과 관련된 키는?",
    "options": [
      "Primary Key",
      "Foreign Key",
      "Unique Key",
      "Check Key"
    ],
    "answer": "1",
    "explanation": "Foreign Key(외래키)는 참조 무결성을 보장하는 제약조건입니다. 외래키는 다른 테이블의 기본키를 참조하며, 참조하는 값이 반드시 참조되는 테이블에 존재해야 합니다. 이를 통해 테이블 간의 관계를 유지하고 데이터 일관성을 보장합니다.",
    "tags": ["Foreign Key", "참조무결성", "제약조건"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 2,
    "question": "다음 테이블 생성 SQL에서 사용된 제약조건의 개수는?",
    "code_snippet": "CREATE TABLE orders (\n  id INT PRIMARY KEY,\n  user_id INT NOT NULL REFERENCES users(id),\n  amount DECIMAL(10,2) CHECK (amount > 0),\n  status VARCHAR(20) DEFAULT 'pending'\n);",
    "options": [
      "2개",
      "3개",
      "4개",
      "5개"
    ],
    "answer": "2",
    "explanation": "사용된 제약조건: 1) PRIMARY KEY (id), 2) NOT NULL (user_id), 3) REFERENCES/FOREIGN KEY (user_id), 4) CHECK (amount > 0). DEFAULT는 제약조건이 아닌 기본값 설정입니다. 총 4개의 제약조건이 사용되었습니다.",
    "tags": ["제약조건", "PRIMARY KEY", "FOREIGN KEY", "CHECK"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 1,
    "question": "UNIQUE 제약조건이 설정된 컬럼에는 NULL 값을 저장할 수 없다.",
    "options": null,
    "answer": "false",
    "explanation": "UNIQUE 제약조건은 중복 값을 허용하지 않지만, 대부분의 DBMS에서 NULL 값은 허용됩니다. NULL은 '알 수 없는 값'으로 취급되어 중복으로 간주하지 않기 때문입니다. 단, PRIMARY KEY는 UNIQUE + NOT NULL이므로 NULL을 허용하지 않습니다.",
    "tags": ["UNIQUE", "NULL", "제약조건"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "외래키(Foreign Key) 제약조건에서 ON DELETE CASCADE의 의미는?",
    "options": [
      "부모 레코드 삭제 시 에러 발생",
      "부모 레코드 삭제 시 자식 레코드도 함께 삭제",
      "부모 레코드 삭제 시 자식의 외래키를 NULL로 설정",
      "부모 레코드 삭제 시 아무 동작 없음"
    ],
    "answer": "1",
    "explanation": "ON DELETE CASCADE는 부모 테이블의 레코드가 삭제될 때 해당 레코드를 참조하는 자식 테이블의 레코드도 함께 삭제됩니다. 다른 옵션으로 RESTRICT(삭제 방지), SET NULL(NULL 설정), SET DEFAULT(기본값 설정), NO ACTION 등이 있습니다.",
    "tags": ["Foreign Key", "CASCADE", "참조무결성"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 3,
    "question": "반정규화(Denormalization)를 수행하는 주된 목적은?",
    "options": [
      "데이터 무결성 강화",
      "저장 공간 절약",
      "조회 성능 향상",
      "데이터 중복 제거"
    ],
    "answer": "2",
    "explanation": "반정규화는 정규화된 테이블을 의도적으로 중복을 허용하여 조회 성능을 향상시키는 기법입니다. JOIN 연산을 줄여 읽기 성능을 개선하지만, 데이터 중복으로 인한 저장 공간 증가와 갱신 이상 현상이 발생할 수 있습니다. 읽기가 쓰기보다 훨씬 많은 경우 고려합니다.",
    "tags": ["반정규화", "성능최적화", "정규화"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 3,
    "question": "다음 중 정규화가 필요한 테이블은?",
    "code_snippet": "-- 테이블: 주문\n-- 주문ID | 고객명 | 고객전화 | 상품명 | 상품가격 | 수량\n\n-- 테이블: 학생\n-- 학번 | 이름 | 학과코드 | 학과명 | 학과위치",
    "options": [
      "주문 테이블만",
      "학생 테이블만",
      "두 테이블 모두",
      "두 테이블 모두 정규화 불필요"
    ],
    "answer": "2",
    "explanation": "두 테이블 모두 정규화가 필요합니다. 주문 테이블: 고객정보(고객명, 고객전화)가 중복 저장됨 → 고객 테이블 분리 필요. 학생 테이블: 학과정보(학과명, 학과위치)가 학과코드에 이행 종속됨(3NF 위반) → 학과 테이블 분리 필요. 두 테이블 모두 갱신 이상이 발생할 수 있습니다.",
    "tags": ["정규화", "갱신이상", "테이블설계"],
    "source": null
  }
]

[
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "다음 중 NoSQL 데이터베이스의 특징으로 올바른 것은?",
    "options": [
      "항상 ACID 트랜잭션을 완벽히 지원한다",
      "스키마가 고정되어 있어 구조 변경이 어렵다",
      "수평적 확장(Scale-out)에 유리하다",
      "JOIN 연산이 관계형 DB보다 효율적이다"
    ],
    "answer": "2",
    "explanation": "NoSQL은 유연한 스키마와 수평적 확장(샤딩)에 유리합니다. 일반적으로 ACID 대신 BASE(Basically Available, Soft state, Eventually consistent)를 따르며, JOIN 연산은 지원하지 않거나 비효율적입니다. 대용량 데이터와 높은 처리량이 필요한 경우에 적합합니다.",
    "tags": ["NoSQL", "수평확장", "스키마"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "다음 NoSQL 유형과 대표 제품의 연결이 올바른 것은?",
    "options": [
      "Document DB - Redis",
      "Key-Value Store - MongoDB",
      "Column Family - Cassandra",
      "Graph DB - Elasticsearch"
    ],
    "answer": "2",
    "explanation": "Column Family: Cassandra, HBase / Document DB: MongoDB, CouchDB / Key-Value: Redis, DynamoDB / Graph DB: Neo4j, Amazon Neptune / Search Engine: Elasticsearch. 각 유형은 특정 사용 사례에 최적화되어 있습니다.",
    "tags": ["NoSQL", "MongoDB", "Cassandra", "Redis"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 2,
    "question": "CAP 정리에 따르면 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance)을 모두 만족할 수 있다.",
    "options": null,
    "answer": "false",
    "explanation": "CAP 정리에 따르면 분산 시스템에서는 C, A, P 중 최대 2가지만 보장할 수 있습니다. 네트워크 분할은 피할 수 없으므로 실제로는 CP(일관성+분할내성) 또는 AP(가용성+분할내성) 중 선택합니다. 예: MongoDB는 CP, Cassandra는 AP 성향입니다.",
    "tags": ["CAP정리", "분산시스템", "NoSQL"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 1,
    "question": "ORM(Object-Relational Mapping)의 주된 장점은?",
    "options": [
      "항상 최적화된 SQL을 생성한다",
      "객체와 관계형 데이터 간의 매핑을 자동화한다",
      "NoSQL 데이터베이스를 지원한다",
      "트랜잭션 관리가 불필요해진다"
    ],
    "answer": "1",
    "explanation": "ORM은 객체 지향 프로그래밍과 관계형 데이터베이스 사이의 패러다임 불일치를 해결합니다. SQL을 직접 작성하지 않고 객체를 통해 데이터를 조작할 수 있습니다. 단, 복잡한 쿼리나 대용량 데이터 처리 시 성능 최적화가 필요할 수 있습니다.",
    "tags": ["ORM", "객체매핑", "TypeORM", "Prisma"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 2,
    "question": "다음 SQL에서 발생할 수 있는 문제는?",
    "code_snippet": "-- 1000명의 사용자 목록 조회 후\n-- 각 사용자의 주문을 별도 쿼리로 조회\n\nSELECT * FROM users; -- 1번 실행\n\n-- 아래 쿼리가 1000번 실행됨\nSELECT * FROM orders WHERE user_id = ?;",
    "options": [
      "데드락",
      "N+1 문제",
      "팬텀 리드",
      "카테시안 곱"
    ],
    "answer": "1",
    "explanation": "N+1 문제는 1번의 목록 조회 후 각 항목에 대해 N번의 추가 쿼리가 발생하는 비효율적인 패턴입니다. 위 예시에서는 1001번의 쿼리가 실행됩니다. JOIN이나 IN 절을 사용한 배치 로딩, ORM의 Eager Loading으로 해결할 수 있습니다.",
    "tags": ["N+1문제", "ORM", "성능최적화"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 2,
    "question": "데이터베이스 파티셔닝의 주된 목적이 아닌 것은?",
    "options": [
      "대용량 테이블의 관리 효율성 향상",
      "쿼리 성능 향상",
      "데이터 무결성 강화",
      "오래된 데이터의 효율적인 삭제"
    ],
    "answer": "2",
    "explanation": "파티셔닝은 대용량 테이블을 작은 단위로 나누어 관리합니다. 쿼리 시 필요한 파티션만 스캔하여 성능이 향상되고, 오래된 파티션만 DROP하여 대량 삭제가 가능합니다. 무결성 강화는 파티셔닝의 목적이 아닙니다.",
    "tags": ["파티셔닝", "성능최적화", "대용량"],
    "source": null
  },
  {
    "category": "database",
    "type": "ox",
    "difficulty": 2,
    "question": "수직 파티셔닝(Vertical Partitioning)은 테이블의 컬럼을 기준으로 나누는 방식이다.",
    "options": null,
    "answer": "true",
    "explanation": "수직 파티셔닝은 컬럼을 기준으로, 수평 파티셔닝(샤딩)은 행을 기준으로 테이블을 분할합니다. 수직 파티셔닝은 자주 사용하는 컬럼과 그렇지 않은 컬럼을 분리하거나, 정규화의 일종으로 볼 수 있습니다. 수평 파티셔닝은 Range, List, Hash 방식 등이 있습니다.",
    "tags": ["파티셔닝", "샤딩", "수직분할"],
    "source": null
  },
  {
    "category": "database",
    "type": "code",
    "difficulty": 3,
    "question": "다음 쿼리의 실행 계획에서 가장 비효율적인 부분은?",
    "code_snippet": "SELECT *\nFROM orders o\nJOIN order_items oi ON o.id = oi.order_id\nWHERE YEAR(o.created_at) = 2024\n  AND oi.quantity > 10;",
    "options": [
      "SELECT *로 모든 컬럼 조회",
      "YEAR() 함수로 인한 인덱스 미사용",
      "JOIN 조건이 명시적이지 않음",
      "WHERE 절의 조건 순서"
    ],
    "answer": "1",
    "explanation": "YEAR(created_at) = 2024처럼 컬럼에 함수를 적용하면 해당 컬럼의 인덱스를 사용할 수 없습니다(인덱스 컬럼 가공). created_at >= '2024-01-01' AND created_at < '2025-01-01'처럼 범위 조건으로 변경해야 인덱스를 활용할 수 있습니다.",
    "tags": ["인덱스", "실행계획", "쿼리최적화"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 3,
    "question": "다음 중 데이터베이스 레플리케이션(Replication)의 주된 목적이 아닌 것은?",
    "options": [
      "읽기 부하 분산",
      "고가용성(HA) 확보",
      "데이터 무결성 검증",
      "재해 복구(DR) 대비"
    ],
    "answer": "2",
    "explanation": "레플리케이션은 데이터를 여러 서버에 복제하여 읽기 부하 분산, 고가용성(장애 시 페일오버), 재해 복구를 위한 백업을 제공합니다. 무결성 검증은 제약조건이나 트리거의 역할이며, 레플리케이션의 주된 목적이 아닙니다.",
    "tags": ["레플리케이션", "고가용성", "읽기분산"],
    "source": null
  },
  {
    "category": "database",
    "type": "multiple",
    "difficulty": 3,
    "question": "다음 중 프론트엔드 개발자가 Supabase나 Firebase 같은 BaaS를 사용할 때 주의해야 할 보안 사항이 아닌 것은?",
    "options": [
      "Row Level Security(RLS) 정책 설정",
      "API 키 노출 방지",
      "클라이언트에서 직접 민감한 쿼리 실행 금지",
      "서버 측 물리적 보안 관리"
    ],
    "answer": "3",
    "explanation": "BaaS 사용 시 RLS로 행 단위 접근 제어, API 키 관리, 클라이언트 쿼리 제한이 중요합니다. 서버 물리적 보안은 BaaS 제공업체의 책임이며, 개발자는 애플리케이션 수준의 보안에 집중해야 합니다. Supabase에서는 RLS가 기본적으로 비활성화되어 있으니 반드시 설정해야 합니다.",
    "tags": ["BaaS", "보안", "RLS", "Supabase"],
    "source": null
  }
]

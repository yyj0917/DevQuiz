[
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "멀티프로세스 대비 멀티스레드의 장점으로 올바른 것은?",
    "options": [
      "한 스레드의 오류가 다른 스레드에 영향을 주지 않는다",
      "스레드 간 메모리를 공유하여 통신 비용이 낮고, 컨텍스트 스위칭이 빠르다",
      "각 스레드가 독립적인 메모리 공간을 가져 안정성이 높다",
      "디버깅이 더 쉽다"
    ],
    "answer": "1",
    "explanation": "멀티스레드는 힙, 코드, 데이터 영역을 공유하므로 IPC 없이 빠르게 통신할 수 있고, 스택과 레지스터만 교체하면 되어 컨텍스트 스위칭이 가볍습니다. 단점은 한 스레드의 오류(세그폴트 등)가 전체 프로세스에 영향을 주고, 공유 자원 동기화가 필요하며 디버깅이 어렵습니다. 멀티프로세스는 격리되어 안정적이지만 통신 비용이 높습니다.",
    "tags": ["멀티스레드", "멀티프로세스", "컨텍스트스위칭", "장단점"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "데드락 해결 방법 중 '회피(Avoidance)'에 해당하는 것은?",
    "options": [
      "자원을 한꺼번에 요청하도록 강제하여 점유와 대기를 제거한다",
      "데드락 발생 여부를 주기적으로 검사하여 발견 시 복구한다",
      "자원 할당 전에 안전 상태인지 확인하고, 불안전하면 할당을 거부한다",
      "데드락 발생 시 관련 프로세스를 모두 종료시킨다"
    ],
    "answer": "2",
    "explanation": "회피는 시스템이 항상 안전 상태(Safe State)를 유지하도록 자원을 할당합니다. 은행원 알고리즘이 대표적입니다. 예방(Prevention)은 4가지 필요조건 중 하나 이상을 원천 차단하고, 탐지(Detection)는 데드락 발생을 허용하되 주기적으로 검사하며, 복구(Recovery)는 탐지 후 프로세스 종료나 자원 선점으로 해결합니다.",
    "tags": ["데드락", "회피", "안전상태", "데드락해결"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "은행원 알고리즘(Banker's Algorithm)에 대한 설명으로 올바른 것은?",
    "options": [
      "데드락이 발생한 후 이를 탐지하고 복구하는 알고리즘이다",
      "프로세스가 최대 자원 요구량을 미리 선언하고, 자원 할당 시 안전 순서가 존재하는지 확인하는 알고리즘이다",
      "가장 먼저 자원을 요청한 프로세스에게 우선 할당하는 알고리즘이다",
      "자원의 순환 대기를 깨기 위해 자원에 번호를 부여하는 알고리즘이다"
    ],
    "answer": "1",
    "explanation": "은행원 알고리즘은 데드락 회피 기법으로, 각 프로세스가 최대 자원 요구량을 미리 알려야 합니다. 자원 요청 시 '이 할당 후에도 모든 프로세스가 완료될 수 있는 안전 순서가 존재하는가?'를 검사합니다. 안전하면 할당, 불안전하면 거부합니다. 단점은 최대 요구량을 미리 알아야 하고, 오버헤드가 크다는 것입니다.",
    "tags": ["은행원알고리즘", "데드락회피", "안전순서", "자원할당"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 1,
    "question": "선점형(Preemptive) 스케줄링에 대한 설명으로 올바른 것은?",
    "options": [
      "프로세스가 자발적으로 CPU를 반납할 때까지 기다린다",
      "실행 중인 프로세스로부터 CPU를 강제로 빼앗아 다른 프로세스에 할당할 수 있다",
      "항상 먼저 도착한 프로세스가 먼저 실행된다",
      "오버헤드가 없어 가장 효율적이다"
    ],
    "answer": "1",
    "explanation": "선점형 스케줄링은 운영체제가 실행 중인 프로세스를 중단시키고 다른 프로세스에 CPU를 할당할 수 있습니다. Round Robin, SRTF, 우선순위(선점형) 등이 해당됩니다. 응답 시간이 중요한 대화형 시스템에 적합하지만, 컨텍스트 스위칭 오버헤드가 있습니다. 비선점형(FCFS, SJF)은 프로세스가 자발적으로 CPU를 반납할 때까지 기다립니다.",
    "tags": ["선점형", "비선점형", "CPU스케줄링", "컨텍스트스위칭"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "우선순위 역전(Priority Inversion) 현상에 대한 설명으로 올바른 것은?",
    "options": [
      "높은 우선순위 프로세스가 항상 먼저 실행되는 정상적인 현상",
      "낮은 우선순위 프로세스가 자원을 점유하여, 높은 우선순위 프로세스가 대기하는 현상",
      "모든 프로세스의 우선순위가 동일해지는 현상",
      "CPU 사용률이 0%로 떨어지는 현상"
    ],
    "answer": "1",
    "explanation": "우선순위 역전은 낮은 우선순위 프로세스 L이 자원을 점유한 상태에서 높은 우선순위 프로세스 H가 해당 자원을 요청하면, H가 L을 기다려야 하는 상황입니다. 이때 중간 우선순위 M이 L을 선점하면 H는 더 오래 대기합니다. 해결책으로 우선순위 상속(L이 H의 우선순위를 임시로 상속)이나 우선순위 천장 프로토콜을 사용합니다.",
    "tags": ["우선순위역전", "우선순위상속", "동기화", "실시간시스템"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "메모리 동적 할당 기법 중 Best Fit에 대한 설명으로 올바른 것은?",
    "options": [
      "첫 번째로 발견된 충분한 크기의 빈 공간에 할당한다",
      "요청 크기와 가장 비슷한(가장 작은 충분한) 빈 공간에 할당한다",
      "가장 큰 빈 공간에 할당한다",
      "가장 최근에 사용된 공간에 할당한다"
    ],
    "answer": "1",
    "explanation": "Best Fit은 요청 크기 이상인 빈 공간 중 가장 작은 것을 선택합니다. 메모리 낭비를 최소화하려는 의도지만, 아주 작은 조각들이 많이 생겨 외부 단편화가 심해질 수 있고 검색 시간이 깁니다. First Fit(처음 찾은 곳), Worst Fit(가장 큰 곳)도 있으며, 일반적으로 First Fit이 속도와 활용률 면에서 균형이 좋습니다.",
    "tags": ["BestFit", "FirstFit", "메모리할당", "외부단편화"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 1,
    "question": "가상 주소(Virtual Address)는 프로세스가 사용하는 논리적 주소이며, MMU에 의해 물리 주소로 변환된다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 프로세스는 가상 주소 공간에서 동작하며, 실제 메모리 접근 시 MMU(Memory Management Unit)가 페이지 테이블을 참조하여 물리 주소로 변환합니다. 이를 통해 각 프로세스는 독립된 주소 공간을 가지고, 실제 물리 메모리 레이아웃을 알 필요 없이 프로그래밍할 수 있습니다. 메모리 보호와 가상 메모리 구현의 핵심입니다.",
    "tags": ["가상주소", "물리주소", "MMU", "주소변환"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "DMA(Direct Memory Access)는 CPU의 개입 없이 I/O 장치가 메모리와 직접 데이터를 주고받을 수 있게 하는 기술이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. DMA 없이는 CPU가 I/O 데이터 전송을 직접 처리해야 하므로 비효율적입니다. DMA 컨트롤러를 사용하면 CPU는 전송 명령만 내리고 다른 작업을 수행할 수 있으며, 전송 완료 시 인터럽트로 알림받습니다. 대용량 데이터 전송(디스크, 네트워크 등)에서 필수적이며, CPU 사용률을 크게 낮춰줍니다.",
    "tags": ["DMA", "I/O", "메모리전송", "CPU효율"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "동기(Synchronous) I/O는 I/O 작업이 완료될 때까지 프로세스가 대기하며, 비동기(Asynchronous) I/O는 요청 후 바로 다른 작업을 계속한다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 동기 I/O에서 프로세스는 read(), write() 등의 호출 후 완료까지 블로킹됩니다. 비동기 I/O는 요청만 하고 즉시 리턴하여 다른 작업을 계속하며, 완료 시 콜백이나 시그널로 알림받습니다. 비동기 I/O는 높은 동시성이 필요한 서버에서 유용하며, Node.js의 이벤트 루프가 대표적인 활용 예입니다.",
    "tags": ["동기I/O", "비동기I/O", "블로킹", "논블로킹"],
    "source": null
  },
  {
    "category": "os",
    "type": "blank",
    "difficulty": 1,
    "question": "파일 시스템에서 파일의 이름, 크기, 위치, 권한 등의 메타데이터를 저장하는 자료구조를 Unix/Linux에서는 _____라고 한다.",
    "options": null,
    "answer": "아이노드",
    "explanation": "아이노드(inode, index node)는 Unix/Linux 파일 시스템에서 파일의 메타데이터를 저장하는 자료구조입니다. 파일 크기, 소유자, 권한, 타임스탬프, 데이터 블록 포인터 등을 포함합니다. 파일 이름은 디렉토리 엔트리에 저장되어 아이노드 번호와 매핑됩니다. 하드 링크는 같은 아이노드를 가리키는 여러 이름입니다.",
    "tags": ["아이노드", "파일시스템", "메타데이터", "Unix"],
    "source": null
  }
]

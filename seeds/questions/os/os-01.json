[
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 1,
    "question": "프로세스(Process)에 대한 설명으로 올바른 것은?",
    "options": [
      "프로세스는 메모리에 적재되지 않은 프로그램이다",
      "프로세스는 실행 중인 프로그램으로, 독립적인 메모리 공간을 갖는다",
      "하나의 프로그램은 항상 하나의 프로세스만 생성할 수 있다",
      "프로세스는 CPU만 할당받으며 메모리는 공유한다"
    ],
    "answer": "1",
    "explanation": "프로세스는 실행 중인 프로그램의 인스턴스로, 각 프로세스는 독립적인 메모리 공간(코드, 데이터, 힙, 스택)을 할당받습니다. 하나의 프로그램에서 여러 프로세스를 생성할 수 있으며(예: 크롬 탭), 프로세스는 CPU, 메모리, 파일 등 다양한 자원을 할당받습니다.",
    "tags": ["프로세스", "메모리", "기본개념"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "프로세스와 스레드의 차이점으로 올바른 것은?",
    "options": [
      "스레드는 프로세스보다 생성 비용이 높다",
      "프로세스 간에는 메모리를 공유하지만, 스레드 간에는 공유하지 않는다",
      "스레드는 같은 프로세스 내에서 힙 영역을 공유하지만, 스택은 각자 갖는다",
      "하나의 프로세스에는 반드시 하나의 스레드만 존재한다"
    ],
    "answer": "2",
    "explanation": "스레드는 같은 프로세스 내에서 코드, 데이터, 힙 영역을 공유하지만, 각 스레드는 독립적인 스택과 레지스터를 갖습니다. 이로 인해 스레드 간 통신이 프로세스 간 통신(IPC)보다 빠르고, 생성 비용도 낮습니다. 하나의 프로세스는 여러 스레드를 가질 수 있습니다(멀티스레딩).",
    "tags": ["프로세스", "스레드", "메모리공유", "스택"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "다음 중 데드락(Deadlock) 발생의 4가지 필요조건에 해당하지 않는 것은?",
    "options": [
      "상호 배제 (Mutual Exclusion)",
      "점유와 대기 (Hold and Wait)",
      "선점 가능 (Preemption)",
      "순환 대기 (Circular Wait)"
    ],
    "answer": "2",
    "explanation": "데드락의 4가지 필요조건은 상호 배제, 점유와 대기, 비선점(No Preemption), 순환 대기입니다. '선점 가능'이 아니라 '비선점'이 조건입니다. 즉, 자원을 강제로 빼앗을 수 없어야 데드락이 발생할 수 있습니다. 이 4가지 조건이 모두 만족되어야 데드락이 발생하며, 하나라도 깨면 데드락을 예방할 수 있습니다.",
    "tags": ["데드락", "동기화", "상호배제", "필요조건"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "CPU 스케줄링 알고리즘 중 Round Robin(RR)에 대한 설명으로 올바른 것은?",
    "options": [
      "실행 시간이 가장 짧은 프로세스를 먼저 실행한다",
      "각 프로세스에 동일한 타임 퀀텀을 할당하고, 시간이 지나면 다음 프로세스로 전환한다",
      "우선순위가 높은 프로세스가 항상 먼저 실행된다",
      "먼저 도착한 프로세스가 완료될 때까지 CPU를 독점한다"
    ],
    "answer": "1",
    "explanation": "Round Robin은 각 프로세스에 동일한 시간(타임 퀀텀/타임 슬라이스)을 할당하고, 시간이 만료되면 준비 큐의 다음 프로세스로 전환하는 선점형 스케줄링입니다. 타임 퀀텀이 너무 크면 FCFS와 같아지고, 너무 작으면 컨텍스트 스위칭 오버헤드가 증가합니다. 대화형 시스템에서 응답 시간을 균등하게 보장하는 데 적합합니다.",
    "tags": ["CPU스케줄링", "RoundRobin", "타임퀀텀", "선점형"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "가상 메모리 시스템에서 페이지 폴트(Page Fault)가 발생했을 때 일어나는 과정으로 올바른 것은?",
    "options": [
      "해당 프로세스를 즉시 종료시킨다",
      "CPU가 직접 디스크에서 페이지를 읽어온다",
      "운영체제가 디스크에서 해당 페이지를 메모리로 로드하고, 페이지 테이블을 갱신한다",
      "해당 페이지를 영구적으로 사용 불가 상태로 표시한다"
    ],
    "answer": "2",
    "explanation": "페이지 폴트 발생 시: (1) CPU가 트랩을 발생시켜 운영체제에 제어권 전달 (2) 운영체제가 해당 페이지의 디스크 위치 확인 (3) 디스크에서 빈 프레임으로 페이지 로드 (4) 페이지 테이블 갱신 (valid bit 설정) (5) 중단된 명령어 재실행. 이 과정에서 빈 프레임이 없으면 페이지 교체 알고리즘(LRU, FIFO 등)이 사용됩니다.",
    "tags": ["가상메모리", "페이지폴트", "페이지테이블", "메모리관리"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점으로 올바른 것은?",
    "options": [
      "뮤텍스는 여러 스레드가 동시에 획득할 수 있지만, 세마포어는 하나의 스레드만 획득 가능하다",
      "뮤텍스는 락을 획득한 스레드만 해제할 수 있지만, 세마포어는 다른 스레드도 시그널을 보낼 수 있다",
      "세마포어는 이진값만 가질 수 있지만, 뮤텍스는 정수값을 가질 수 있다",
      "뮤텍스와 세마포어는 완전히 동일한 개념이다"
    ],
    "answer": "1",
    "explanation": "뮤텍스는 소유권 개념이 있어 락을 획득한 스레드만 해제할 수 있습니다(1개 자원 보호). 세마포어는 소유권이 없어 어떤 스레드든 wait/signal을 호출할 수 있고, 카운팅 세마포어는 N개의 자원을 관리할 수 있습니다. 뮤텍스는 상호 배제에, 세마포어는 동기화와 자원 카운팅에 주로 사용됩니다.",
    "tags": ["뮤텍스", "세마포어", "동기화", "상호배제"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 1,
    "question": "컨텍스트 스위칭(Context Switching)은 CPU가 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하는 과정이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 컨텍스트 스위칭은 CPU가 한 프로세스에서 다른 프로세스로 전환할 때, 현재 프로세스의 상태(PC, 레지스터, 메모리 맵 등)를 PCB(Process Control Block)에 저장하고, 새로운 프로세스의 상태를 PCB에서 복원하는 과정입니다. 이 과정은 순수한 오버헤드로, 너무 자주 발생하면 시스템 성능이 저하됩니다.",
    "tags": ["컨텍스트스위칭", "PCB", "프로세스"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "스레드는 프로세스 내에서 스택 영역을 공유하기 때문에 멀티스레드 프로그래밍에서 지역 변수는 항상 동기화가 필요하다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. 스레드는 힙, 코드, 데이터 영역은 공유하지만, 스택은 각 스레드마다 독립적으로 갖습니다. 따라서 지역 변수는 각 스레드의 스택에 저장되므로 동기화가 필요 없습니다. 동기화가 필요한 것은 공유 자원(전역 변수, 힙 메모리, 파일 등)에 접근할 때입니다.",
    "tags": ["스레드", "스택", "동기화", "지역변수"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "시스템 콜(System Call)은 사용자 모드에서 커널 모드로 전환하여 운영체제의 서비스를 요청하는 인터페이스이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 시스템 콜은 응용 프로그램이 파일 읽기/쓰기, 프로세스 생성, 네트워크 통신 등 운영체제의 서비스가 필요할 때 사용하는 인터페이스입니다. 시스템 콜 호출 시 트랩이 발생하여 사용자 모드에서 커널 모드로 전환되고, 작업 완료 후 다시 사용자 모드로 돌아갑니다. 예: open(), read(), write(), fork(), exec()",
    "tags": ["시스템콜", "커널모드", "사용자모드", "트랩"],
    "source": null
  },
  {
    "category": "os",
    "type": "blank",
    "difficulty": 1,
    "question": "프로세스의 5가지 상태 중, CPU를 할당받아 명령어를 실행하고 있는 상태를 _____ 상태라고 한다.",
    "options": null,
    "answer": "실행",
    "explanation": "프로세스의 5가지 상태는 생성(New), 준비(Ready), 실행(Running), 대기(Waiting/Blocked), 종료(Terminated)입니다. 실행 상태는 프로세스가 CPU를 할당받아 실제로 명령어를 수행하는 상태입니다. 준비 상태는 CPU만 할당받으면 바로 실행 가능한 상태이고, 대기 상태는 I/O 완료 등 특정 이벤트를 기다리는 상태입니다.",
    "tags": ["프로세스상태", "실행상태", "상태전이"],
    "source": null
  }
]

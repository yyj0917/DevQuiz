[
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "Copy-on-Write(COW)에 대한 설명으로 올바른 것은?",
    "options": [
      "데이터를 읽을 때마다 복사본을 만드는 기법",
      "fork() 시 부모와 자식이 메모리 페이지를 공유하다가, 쓰기가 발생할 때만 복사하는 기법",
      "파일을 쓸 때 항상 새 파일을 생성하는 기법",
      "캐시에 데이터를 쓸 때 바로 메모리에도 쓰는 기법"
    ],
    "answer": "1",
    "explanation": "Copy-on-Write는 fork() 시 자식 프로세스가 부모의 메모리 페이지를 즉시 복사하지 않고 공유합니다. 해당 페이지는 읽기 전용으로 표시되며, 둘 중 하나가 쓰기를 시도하면 그때 해당 페이지만 복사합니다. 이를 통해 fork() 후 exec()하는 일반적인 패턴에서 불필요한 복사를 피해 성능을 크게 향상시킵니다.",
    "tags": ["CopyOnWrite", "fork", "메모리최적화", "지연복사"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "다단계 페이지 테이블(Multi-level Page Table)을 사용하는 주된 이유는?",
    "options": [
      "주소 변환 속도를 높이기 위해",
      "페이지 테이블의 메모리 공간을 절약하기 위해",
      "페이지 폴트를 줄이기 위해",
      "외부 단편화를 해결하기 위해"
    ],
    "answer": "1",
    "explanation": "32비트 시스템에서 4KB 페이지를 사용하면 2^20개의 페이지 테이블 엔트리가 필요해 약 4MB의 연속 공간이 필요합니다. 다단계 페이지 테이블은 이를 계층적으로 나눠, 실제 사용하는 부분의 테이블만 메모리에 올립니다. 대부분의 주소 공간이 비어있는 프로세스에서 메모리를 크게 절약합니다. 64비트 시스템은 4단계 이상을 사용합니다.",
    "tags": ["다단계페이지테이블", "페이지테이블", "메모리절약", "가상메모리"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "워킹셋(Working Set) 모델에 대한 설명으로 올바른 것은?",
    "options": [
      "프로세스가 실행되는 동안 사용한 모든 페이지의 집합",
      "특정 시간 윈도우 동안 프로세스가 참조한 페이지들의 집합으로, 스래싱 방지에 사용된다",
      "메모리에 상주하는 모든 프로세스의 페이지 집합",
      "디스크에 스왑 아웃된 페이지들의 집합"
    ],
    "answer": "1",
    "explanation": "워킹셋은 최근 일정 시간(Δ) 동안 프로세스가 참조한 페이지들의 집합입니다. 프로세스에게 워킹셋 크기만큼의 프레임을 할당하면 페이지 폴트를 최소화할 수 있습니다. 워킹셋 합이 가용 프레임보다 크면 일부 프로세스를 중단시켜 스래싱을 방지합니다. 지역성(Locality) 원리에 기반한 개념입니다.",
    "tags": ["워킹셋", "스래싱방지", "지역성", "메모리관리"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "우선순위 스케줄링에서 발생할 수 있는 기아(Starvation) 문제의 해결책으로 적절한 것은?",
    "options": [
      "타임 퀀텀을 늘린다",
      "에이징(Aging) 기법을 적용하여 대기 시간에 따라 우선순위를 점진적으로 높인다",
      "모든 프로세스의 우선순위를 동일하게 설정한다",
      "비선점형으로 변경한다"
    ],
    "answer": "1",
    "explanation": "우선순위 스케줄링에서 낮은 우선순위 프로세스는 높은 우선순위 프로세스가 계속 도착하면 무한정 대기할 수 있습니다(기아). 에이징은 프로세스가 대기한 시간에 비례하여 우선순위를 점진적으로 높여주는 기법으로, 결국 모든 프로세스가 실행될 수 있게 합니다. SJF에서도 같은 방식으로 기아를 해결할 수 있습니다.",
    "tags": ["우선순위스케줄링", "기아", "에이징", "CPU스케줄링"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "모니터(Monitor)에 대한 설명으로 올바른 것은?",
    "options": [
      "하드웨어 기반의 동기화 도구로, CPU에서 직접 지원한다",
      "세마포어보다 저수준의 동기화 도구이다",
      "상호 배제가 자동으로 보장되는 고수준 동기화 구조로, 조건 변수(condition variable)를 사용한다",
      "데드락을 완전히 방지해주는 동기화 도구이다"
    ],
    "answer": "2",
    "explanation": "모니터는 공유 데이터와 그에 대한 연산을 하나의 모듈로 캡슐화한 고수준 동기화 구조입니다. 한 번에 하나의 프로세스만 모니터 내 함수를 실행할 수 있어 상호 배제가 자동 보장됩니다. 조건 변수(wait, signal)로 동기화를 세밀하게 제어합니다. Java의 synchronized, C#의 lock이 모니터 개념을 구현한 예입니다.",
    "tags": ["모니터", "동기화", "조건변수", "상호배제"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "Unix/Linux의 파이프(Pipe)에 대한 설명으로 올바른 것은?",
    "options": [
      "네트워크를 통해 다른 컴퓨터의 프로세스와 통신할 수 있다",
      "양방향 통신이 가능한 IPC 방식이다",
      "단방향 통신 채널로, 주로 부모-자식 프로세스 간 통신에 사용된다",
      "영구적으로 존재하여 프로세스 종료 후에도 데이터가 유지된다"
    ],
    "answer": "2",
    "explanation": "파이프는 단방향 바이트 스트림으로, 한쪽에서 쓰고 다른 쪽에서 읽습니다. 익명 파이프는 fork()로 생성된 부모-자식 간 통신에 사용되며, 프로세스 종료 시 사라집니다. 양방향 통신이 필요하면 파이프 2개를 사용합니다. 명명된 파이프(FIFO)는 파일 시스템에 존재하여 무관한 프로세스 간에도 사용 가능합니다.",
    "tags": ["파이프", "IPC", "단방향통신", "Unix"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "Optimal 페이지 교체 알고리즘은 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하므로 이론적으로 최적이지만, 미래를 예측할 수 없어 실제 구현은 불가능하다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. Optimal(OPT, Belady's Algorithm)은 앞으로 가장 늦게 사용될 페이지를 교체하여 페이지 폴트를 최소화합니다. 하지만 미래의 참조 패턴을 알 수 없으므로 실제 시스템에서 구현할 수 없습니다. 주로 다른 알고리즘의 성능을 비교하는 기준으로 사용됩니다. LRU는 과거 기반으로 Optimal을 근사합니다.",
    "tags": ["Optimal", "페이지교체", "이론적최적", "LRU"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "실시간 운영체제(RTOS)는 작업의 처리량(throughput)을 최대화하는 것이 주 목표이다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. RTOS의 주 목표는 처리량이 아니라 '데드라인 준수'입니다. 정해진 시간 내에 작업을 완료하는 것이 핵심입니다. Hard Real-Time은 데드라인 위반 시 치명적(항공기, 의료기기), Soft Real-Time은 지연이 허용되지만 바람직하지 않습니다(멀티미디어). 범용 OS는 평균 응답 시간과 처리량을 최적화합니다.",
    "tags": ["RTOS", "실시간", "데드라인", "HardRealTime"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 1,
    "question": "블로킹(Blocking) 방식에서 프로세스는 요청한 작업이 완료될 때까지 대기 상태로 전환된다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 블로킹 방식에서 프로세스가 I/O 요청 등을 하면 해당 작업이 완료될 때까지 실행이 중단되고 대기(Waiting) 상태로 전환됩니다. 작업 완료 시 다시 준비(Ready) 상태가 됩니다. 논블로킹은 요청 후 즉시 반환하여 다른 작업을 계속할 수 있습니다. 동기/비동기는 완료 알림 방식, 블로킹/논블로킹은 대기 여부입니다.",
    "tags": ["블로킹", "논블로킹", "대기상태", "I/O"],
    "source": null
  },
  {
    "category": "os",
    "type": "blank",
    "difficulty": 2,
    "question": "Unix/Linux에서 현재 프로세스의 코드, 데이터, 힙, 스택을 새로운 프로그램으로 완전히 교체하는 시스템 콜은 _____() 계열 함수이다.",
    "options": null,
    "answer": "exec",
    "explanation": "exec() 계열 함수(execl, execv, execve 등)는 현재 프로세스의 주소 공간을 새 프로그램의 코드와 데이터로 완전히 덮어씁니다. PID는 유지되며, 새 프로그램의 main()부터 실행됩니다. 일반적으로 fork()로 자식 프로세스를 생성한 후 exec()을 호출하여 새 프로그램을 실행합니다. exec() 성공 시 원래 코드로 돌아오지 않습니다.",
    "tags": ["exec", "fork", "프로세스생성", "시스템콜"],
    "source": null
  }
]

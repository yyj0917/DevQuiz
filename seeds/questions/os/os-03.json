[
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "페이지 교체 알고리즘 중 LRU(Least Recently Used)에 대한 설명으로 올바른 것은?",
    "options": [
      "앞으로 가장 오랫동안 사용되지 않을 페이지를 교체한다",
      "가장 먼저 들어온 페이지를 교체한다",
      "가장 오랫동안 사용되지 않은 페이지를 교체한다",
      "사용 횟수가 가장 적은 페이지를 교체한다"
    ],
    "answer": "2",
    "explanation": "LRU는 최근에 사용되지 않은 페이지가 앞으로도 사용되지 않을 가능성이 높다는 가정에 기반합니다. 가장 오래 전에 참조된 페이지를 교체합니다. Optimal(앞으로 가장 오래 사용 안 될 페이지 교체)은 이론상 최적이지만 미래를 예측할 수 없어 구현 불가능합니다. FIFO는 먼저 들어온 페이지 교체, LFU는 사용 횟수 기반입니다.",
    "tags": ["LRU", "페이지교체", "가상메모리", "캐시"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "스래싱(Thrashing)에 대한 설명으로 올바른 것은?",
    "options": [
      "CPU 사용률이 100%에 도달하여 시스템이 느려지는 현상",
      "페이지 폴트가 과도하게 발생하여 실제 작업보다 페이지 교체에 더 많은 시간을 소비하는 현상",
      "디스크의 물리적 손상으로 인해 데이터가 손실되는 현상",
      "프로세스가 데드락에 빠져 무한 대기하는 현상"
    ],
    "answer": "1",
    "explanation": "스래싱은 멀티프로그래밍 정도가 너무 높아 각 프로세스에 충분한 프레임이 할당되지 않을 때 발생합니다. 프로세스들이 페이지 폴트를 처리하느라 실제 작업은 거의 하지 못하고, CPU 사용률이 급격히 떨어집니다. 해결책으로는 워킹셋 모델, 페이지 폴트 빈도(PFF) 기반 조절, 프로세스 수 제한 등이 있습니다.",
    "tags": ["스래싱", "페이지폴트", "멀티프로그래밍", "워킹셋"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "Unix/Linux에서 fork() 시스템 콜에 대한 설명으로 올바른 것은?",
    "options": [
      "새로운 스레드를 생성한다",
      "현재 프로세스를 복제하여 자식 프로세스를 생성하고, 부모와 자식 모두 fork() 이후부터 실행을 계속한다",
      "현재 프로세스의 코드를 다른 프로그램으로 교체한다",
      "프로세스를 종료시킨다"
    ],
    "answer": "1",
    "explanation": "fork()는 호출한 프로세스(부모)를 복제하여 새로운 프로세스(자식)를 생성합니다. 자식은 부모의 메모리 공간, 파일 디스크립터 등을 복사받습니다. fork() 반환값은 부모에서 자식 PID, 자식에서 0입니다. exec()은 프로세스의 코드를 다른 프로그램으로 교체합니다. 일반적으로 fork() 후 exec()을 호출하여 새 프로그램을 실행합니다.",
    "tags": ["fork", "프로세스생성", "시스템콜", "Unix"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "좀비 프로세스(Zombie Process)에 대한 설명으로 올바른 것은?",
    "options": [
      "무한 루프에 빠져 CPU를 독점하는 프로세스",
      "자식 프로세스가 종료되었지만, 부모가 종료 상태를 회수하지 않아 프로세스 테이블에 남아있는 상태",
      "부모 프로세스가 먼저 종료되어 init 프로세스에 입양된 프로세스",
      "메모리 누수로 인해 점점 많은 메모리를 차지하는 프로세스"
    ],
    "answer": "1",
    "explanation": "좀비 프로세스는 실행이 끝났지만 부모가 wait()을 호출하지 않아 PCB가 남아있는 상태입니다. 리소스는 거의 사용하지 않지만 프로세스 테이블 공간을 차지합니다. 고아 프로세스는 부모가 먼저 종료되어 init(또는 systemd, PID 1)이 새 부모가 된 프로세스입니다. 고아 프로세스는 init이 wait()을 호출해 정상 종료됩니다.",
    "tags": ["좀비프로세스", "고아프로세스", "wait", "프로세스종료"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "Race Condition(경쟁 상태)에 대한 설명으로 올바른 것은?",
    "options": [
      "두 프로세스가 서로의 자원을 기다리며 무한 대기하는 상태",
      "여러 프로세스가 공유 자원에 동시 접근하여, 실행 순서에 따라 결과가 달라지는 상황",
      "프로세스가 CPU를 할당받기 위해 경쟁하는 정상적인 상황",
      "우선순위가 높은 프로세스가 항상 먼저 실행되는 상황"
    ],
    "answer": "1",
    "explanation": "Race Condition은 여러 프로세스/스레드가 공유 데이터에 동시 접근하고, 최종 결과가 접근 순서에 의존하는 상황입니다. 예: 두 스레드가 동시에 count++를 실행하면 예상과 다른 결과가 나올 수 있습니다. 임계 영역을 설정하고 뮤텍스, 세마포어 등으로 동기화하여 해결합니다. 데드락은 자원을 점유한 채 서로 대기하는 다른 개념입니다.",
    "tags": ["RaceCondition", "경쟁상태", "동기화", "임계영역"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "커널 수준 스레드(Kernel Thread)와 사용자 수준 스레드(User Thread)의 차이점으로 올바른 것은?",
    "options": [
      "커널 스레드는 컨텍스트 스위칭이 빠르고, 사용자 스레드는 느리다",
      "사용자 스레드는 운영체제가 인식하지 못하며, 하나의 스레드가 블로킹되면 전체 프로세스가 블로킹될 수 있다",
      "커널 스레드는 라이브러리로 구현되고, 사용자 스레드는 운영체제가 관리한다",
      "사용자 스레드는 멀티코어를 활용할 수 있지만, 커널 스레드는 활용할 수 없다"
    ],
    "answer": "1",
    "explanation": "사용자 수준 스레드는 커널 개입 없이 라이브러리에서 관리되어 스위칭이 빠르지만, OS가 인식하지 못해 한 스레드가 I/O 등으로 블로킹되면 프로세스 전체가 블로킹됩니다. 커널 스레드는 OS가 직접 관리하여 멀티코어 활용과 개별 스레드 스케줄링이 가능하지만, 커널 모드 전환 오버헤드가 있습니다. 현대 OS는 대부분 1:1 또는 M:N 매핑을 사용합니다.",
    "tags": ["커널스레드", "사용자스레드", "스레드모델", "블로킹"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 1,
    "question": "세그멘테이션(Segmentation)은 프로세스를 논리적 단위(코드, 데이터, 스택 등)로 나누어 메모리에 할당하는 기법이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 세그멘테이션은 프로세스를 의미 있는 논리적 단위(세그먼트)로 분할합니다. 각 세그먼트는 가변 크기이며, 세그먼트 테이블로 관리합니다. 프로그래머 관점에서 자연스럽고 보호와 공유가 용이하지만, 외부 단편화가 발생합니다. 반면 페이징은 고정 크기로 분할하여 외부 단편화는 없지만 내부 단편화가 발생합니다.",
    "tags": ["세그멘테이션", "메모리관리", "논리적분할"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "FIFO 페이지 교체 알고리즘에서 프레임 수를 늘리면 항상 페이지 폴트가 감소한다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. FIFO에서는 Belady's Anomaly(벨레이디의 모순)가 발생할 수 있어, 프레임 수를 늘려도 오히려 페이지 폴트가 증가하는 경우가 있습니다. 이는 FIFO가 페이지의 실제 사용 패턴을 고려하지 않기 때문입니다. LRU, Optimal 같은 스택 알고리즘은 이 현상이 발생하지 않습니다.",
    "tags": ["FIFO", "페이지교체", "BeladyAnomaly", "페이지폴트"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "인터럽트(Interrupt)는 CPU가 현재 실행 중인 작업을 중단하고 특정 이벤트를 처리하도록 하는 메커니즘이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 인터럽트는 하드웨어나 소프트웨어에서 발생한 이벤트를 CPU에 알리는 신호입니다. CPU는 현재 상태를 저장하고 인터럽트 핸들러(ISR)를 실행합니다. 하드웨어 인터럽트(I/O 완료, 타이머 등)와 소프트웨어 인터럽트(트랩, 시스템 콜)로 나뉩니다. 인터럽트 덕분에 폴링 없이 효율적으로 이벤트를 처리할 수 있습니다.",
    "tags": ["인터럽트", "ISR", "하드웨어인터럽트", "소프트웨어인터럽트"],
    "source": null
  },
  {
    "category": "os",
    "type": "blank",
    "difficulty": 1,
    "question": "프로세스 간 통신(IPC) 방법 중, 커널을 통해 메시지를 주고받는 방식을 _____ 패싱이라고 한다.",
    "options": null,
    "answer": "메시지",
    "explanation": "메시지 패싱(Message Passing)은 프로세스 간에 커널을 통해 메시지를 주고받는 IPC 방식입니다. send()와 receive() 연산을 사용하며, 커널이 중개하므로 동기화가 자동으로 처리되어 안전합니다. 하지만 커널 모드 전환과 데이터 복사 오버헤드가 있어 공유 메모리보다 느립니다. 분산 시스템에서도 사용 가능하다는 장점이 있습니다.",
    "tags": ["메시지패싱", "IPC", "프로세스통신", "커널"],
    "source": null
  }
]

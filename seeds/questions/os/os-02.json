[
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 1,
    "question": "PCB(Process Control Block)에 저장되는 정보가 아닌 것은?",
    "options": [
      "프로세스 상태 (Running, Ready 등)",
      "프로그램 카운터 (PC)",
      "다른 프로세스의 메모리 주소",
      "프로세스 ID (PID)"
    ],
    "answer": "2",
    "explanation": "PCB는 각 프로세스의 정보를 저장하는 자료구조로, 프로세스 상태, PID, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보, I/O 상태 등을 포함합니다. 다른 프로세스의 메모리 주소는 해당 프로세스와 무관하며, 프로세스 간 메모리는 격리되어 있어 PCB에 저장되지 않습니다.",
    "tags": ["PCB", "프로세스", "자료구조"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "SJF(Shortest Job First) 스케줄링의 단점으로 가장 적절한 것은?",
    "options": [
      "평균 대기 시간이 가장 길다",
      "실행 시간이 긴 프로세스가 무한정 대기할 수 있다 (기아 현상)",
      "구현이 가장 복잡하다",
      "선점이 불가능하다"
    ],
    "answer": "1",
    "explanation": "SJF는 평균 대기 시간을 최소화하는 최적의 알고리즘이지만, 실행 시간이 긴 프로세스가 계속 후순위로 밀려 무한정 대기하는 기아(Starvation) 현상이 발생할 수 있습니다. 이를 해결하기 위해 에이징(Aging) 기법을 사용하여 대기 시간에 따라 우선순위를 높여줍니다. 참고로 SJF는 선점형(SRTF)과 비선점형 모두 구현 가능합니다.",
    "tags": ["SJF", "CPU스케줄링", "기아현상", "에이징"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "내부 단편화(Internal Fragmentation)에 대한 설명으로 올바른 것은?",
    "options": [
      "메모리의 빈 공간들이 흩어져 있어 큰 프로세스를 할당할 수 없는 현상",
      "할당된 메모리 블록 내부에서 사용되지 않는 공간이 낭비되는 현상",
      "프로세스가 종료된 후에도 메모리가 해제되지 않는 현상",
      "가상 메모리와 물리 메모리의 크기 차이로 인한 현상"
    ],
    "answer": "1",
    "explanation": "내부 단편화는 고정 크기 할당 방식(페이징 등)에서 발생합니다. 예를 들어 페이지 크기가 4KB인데 프로세스가 4.1KB를 요청하면 2페이지(8KB)를 할당받아 3.9KB가 낭비됩니다. 반면 외부 단편화는 가변 크기 할당에서 빈 공간이 흩어져 연속 할당이 불가능한 현상입니다. 페이징은 외부 단편화를 해결하지만 내부 단편화가 발생합니다.",
    "tags": ["내부단편화", "외부단편화", "메모리관리", "페이징"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 2,
    "question": "프로세스 간 통신(IPC) 방법 중 공유 메모리(Shared Memory) 방식의 특징으로 올바른 것은?",
    "options": [
      "커널이 모든 데이터 전송을 중개하므로 가장 안전하다",
      "데이터 복사 없이 메모리를 직접 공유하므로 속도가 빠르지만, 동기화가 필요하다",
      "네트워크를 통해 다른 컴퓨터의 프로세스와도 통신할 수 있다",
      "단방향 통신만 가능하다"
    ],
    "answer": "1",
    "explanation": "공유 메모리는 여러 프로세스가 동일한 메모리 영역에 접근하는 방식으로, 데이터 복사 오버헤드가 없어 가장 빠릅니다. 단, 동시 접근 시 Race Condition이 발생할 수 있어 세마포어나 뮤텍스로 동기화가 필수입니다. 메시지 패싱은 커널이 중개하여 안전하지만 복사 오버헤드가 있고, 소켓은 네트워크 통신이 가능합니다.",
    "tags": ["IPC", "공유메모리", "프로세스통신", "동기화"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "임계 영역(Critical Section) 문제 해결을 위한 3가지 조건에 해당하지 않는 것은?",
    "options": [
      "상호 배제 (Mutual Exclusion)",
      "진행 (Progress)",
      "공정성 (Fairness)",
      "한정 대기 (Bounded Waiting)"
    ],
    "answer": "2",
    "explanation": "임계 영역 문제의 해결 조건은 3가지입니다: (1) 상호 배제 - 한 프로세스가 임계 영역에 있으면 다른 프로세스는 진입 불가 (2) 진행 - 임계 영역이 비어있으면 대기 중인 프로세스가 진입 가능해야 함 (3) 한정 대기 - 진입 요청 후 무한정 대기하지 않아야 함. 공정성(Fairness)은 바람직하지만 필수 조건은 아닙니다.",
    "tags": ["임계영역", "상호배제", "동기화", "한정대기"],
    "source": null
  },
  {
    "category": "os",
    "type": "multiple",
    "difficulty": 3,
    "question": "TLB(Translation Lookaside Buffer)에 대한 설명으로 올바른 것은?",
    "options": [
      "디스크와 메모리 사이의 데이터 전송을 담당하는 버퍼이다",
      "페이지 테이블의 일부를 캐싱하여 주소 변환 속도를 높이는 하드웨어이다",
      "프로세스의 스택 영역을 임시 저장하는 버퍼이다",
      "CPU와 캐시 메모리 사이의 데이터를 관리하는 버퍼이다"
    ],
    "answer": "1",
    "explanation": "TLB는 가상 주소를 물리 주소로 변환할 때 사용하는 고속 캐시입니다. 페이지 테이블은 메모리에 있어 매번 접근하면 느리므로, 최근 사용된 페이지 테이블 항목을 TLB에 캐싱합니다. TLB 히트 시 한 번의 메모리 접근으로 끝나고, TLB 미스 시 페이지 테이블 접근이 추가로 필요합니다. Context Switching 시 TLB를 비워야(flush) 합니다.",
    "tags": ["TLB", "페이지테이블", "주소변환", "캐시"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 1,
    "question": "FCFS(First Come First Served) 스케줄링은 먼저 도착한 프로세스를 먼저 실행하는 비선점형 알고리즘이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. FCFS는 가장 단순한 스케줄링 알고리즘으로, 준비 큐에 도착한 순서대로 CPU를 할당합니다. 비선점형이므로 한 프로세스가 CPU를 잡으면 완료될 때까지 다른 프로세스는 대기합니다. 구현이 간단하지만, 긴 프로세스 뒤에 짧은 프로세스가 오면 평균 대기 시간이 길어지는 Convoy Effect가 발생할 수 있습니다.",
    "tags": ["FCFS", "CPU스케줄링", "비선점형", "ConvoyEffect"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "페이징(Paging) 기법은 외부 단편화를 해결하지만, 내부 단편화는 발생할 수 있다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 페이징은 메모리를 고정 크기의 프레임으로, 프로세스를 같은 크기의 페이지로 나눠 불연속 할당합니다. 이로써 외부 단편화(연속 공간 부족)는 해결됩니다. 하지만 마지막 페이지가 프레임을 완전히 채우지 못하면 내부 단편화가 발생합니다. 반대로 세그멘테이션은 가변 크기라 내부 단편화는 없지만 외부 단편화가 발생합니다.",
    "tags": ["페이징", "내부단편화", "외부단편화", "메모리관리"],
    "source": null
  },
  {
    "category": "os",
    "type": "ox",
    "difficulty": 2,
    "question": "스핀락(Spinlock)은 락을 획득할 때까지 반복문을 돌며 대기하므로, 대기 시간이 짧을 때 효율적이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 스핀락은 락이 해제될 때까지 CPU가 계속 확인하는 바쁜 대기(Busy Waiting) 방식입니다. 컨텍스트 스위칭 오버헤드가 없어 락 보유 시간이 매우 짧을 때 효율적입니다. 하지만 대기 시간이 길면 CPU 자원을 낭비하므로, 이 경우 블로킹 방식(뮤텍스)이 더 적합합니다. 멀티코어 환경에서 주로 사용됩니다.",
    "tags": ["스핀락", "BusyWaiting", "동기화", "멀티코어"],
    "source": null
  },
  {
    "category": "os",
    "type": "blank",
    "difficulty": 1,
    "question": "메모리에 있는 프로세스를 일시적으로 디스크로 내보내고, 다시 메모리로 불러오는 기법을 _____이라고 한다.",
    "options": null,
    "answer": "스와핑",
    "explanation": "스와핑(Swapping)은 메모리 공간이 부족할 때 프로세스 전체를 디스크의 스왑 영역(Swap Space)으로 내보내고(Swap Out), 필요할 때 다시 메모리로 불러오는(Swap In) 기법입니다. 가상 메모리의 페이징과 다르게 프로세스 단위로 이동합니다. 스왑 영역은 보통 디스크의 별도 파티션이나 파일로 구성됩니다.",
    "tags": ["스와핑", "메모리관리", "스왑영역"],
    "source": null
  }
]

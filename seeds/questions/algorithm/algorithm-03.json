[
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 1,
    "question": "그리디(탐욕) 알고리즘의 핵심 특징은?",
    "options": [
      "모든 경우의 수를 탐색한다",
      "각 단계에서 지역적으로 최적인 선택을 한다",
      "작은 문제의 해를 저장하여 재사용한다",
      "문제를 동일한 크기로 분할한다"
    ],
    "answer": "1",
    "explanation": "그리디는 각 단계에서 현재 상황에서 가장 좋아 보이는 선택을 합니다. 지역적 최적 선택이 전역적 최적해를 보장할 때 사용합니다. 거스름돈, 회의실 배정, 최소 신장 트리 등이 대표적입니다. 모든 문제에 적용되지는 않습니다.",
    "tags": ["그리디", "탐욕알고리즘", "최적화"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 2,
    "question": "회의실 배정 문제에서 가장 많은 회의를 선택하기 위한 그리디 전략은?",
    "options": [
      "시작 시간이 빠른 순으로 선택",
      "종료 시간이 빠른 순으로 선택",
      "회의 시간이 짧은 순으로 선택",
      "회의 시간이 긴 순으로 선택"
    ],
    "answer": "1",
    "explanation": "종료 시간이 빠른 회의부터 선택하면 남는 시간이 최대화되어 더 많은 회의를 배치할 수 있습니다. 종료 시간으로 정렬 후 현재 종료 시간보다 늦게 시작하는 회의 중 가장 빨리 끝나는 회의를 선택합니다. 활동 선택 문제의 대표적인 그리디 해법입니다.",
    "tags": ["그리디", "회의실배정", "활동선택"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "ox",
    "difficulty": 2,
    "question": "그리디 알고리즘은 항상 최적해를 보장한다.",
    "options": null,
    "answer": "false",
    "explanation": "그리디는 지역적 최적 선택이 전역적 최적해로 이어지는 특수한 경우에만 최적해를 보장합니다. 예를 들어 500원, 400원, 100원 동전으로 800원을 거슬러 줄 때, 그리디(500+100+100+100)는 4개지만 최적해(400+400)는 2개입니다.",
    "tags": ["그리디", "최적해", "반례"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 1,
    "question": "다음 정렬 알고리즘 중 평균 시간복잡도가 O(n log n)이 아닌 것은?",
    "options": [
      "퀵 정렬",
      "병합 정렬",
      "힙 정렬",
      "버블 정렬"
    ],
    "answer": "3",
    "explanation": "버블 정렬은 평균 및 최악 모두 O(n²)입니다. 퀵 정렬은 평균 O(n log n), 최악 O(n²). 병합 정렬과 힙 정렬은 항상 O(n log n)을 보장합니다. 코딩테스트에서는 보통 내장 정렬 함수(O(n log n))를 사용합니다.",
    "tags": ["정렬", "시간복잡도", "버블정렬"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 2,
    "question": "다음 중 안정 정렬(Stable Sort)인 것은?",
    "code_snippet": "// 안정 정렬: 같은 값의 원래 순서가 유지됨\n// 예: [(A,3), (B,1), (C,3)] 을 숫자 기준 정렬 시\n// 안정: [(B,1), (A,3), (C,3)] - A가 C보다 앞\n// 불안정: [(B,1), (C,3), (A,3)] - 순서 바뀔 수 있음",
    "options": [
      "퀵 정렬",
      "힙 정렬",
      "병합 정렬",
      "선택 정렬"
    ],
    "answer": "2",
    "explanation": "병합 정렬은 대표적인 안정 정렬입니다. 병합 시 같은 값이면 왼쪽(먼저 나온) 것을 먼저 선택하여 순서를 보존합니다. 퀵, 힙, 선택 정렬은 불안정 정렬입니다. JavaScript의 sort()는 브라우저마다 다르지만 최신 버전은 대부분 안정 정렬입니다.",
    "tags": ["정렬", "안정정렬", "병합정렬"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 2,
    "question": "다익스트라(Dijkstra) 알고리즘의 특징으로 올바르지 않은 것은?",
    "options": [
      "음수 가중치가 있으면 사용할 수 없다",
      "우선순위 큐를 사용하면 O((V+E) log V)이다",
      "하나의 시작점에서 모든 정점까지의 최단 거리를 구한다",
      "BFS와 달리 가중치가 없는 그래프에만 사용한다"
    ],
    "answer": "3",
    "explanation": "다익스트라는 가중치가 있는 그래프에서 사용합니다(가중치 없으면 BFS로 충분). 음수 가중치가 있으면 벨만-포드 알고리즘을 사용해야 합니다. 우선순위 큐(힙)를 사용하면 효율적으로 구현할 수 있습니다.",
    "tags": ["다익스트라", "최단거리", "그래프"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 3,
    "question": "다음 코드가 구현하는 알고리즘은?",
    "code_snippet": "class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({length: n}, (_, i) => i);\n  }\n  find(x) {\n    if (this.parent[x] !== x)\n      this.parent[x] = this.find(this.parent[x]);\n    return this.parent[x];\n  }\n  union(x, y) {\n    const px = this.find(x), py = this.find(y);\n    if (px !== py) this.parent[px] = py;\n  }\n}",
    "options": [
      "다익스트라 알고리즘",
      "프림 알고리즘",
      "유니온파인드 (서로소 집합)",
      "위상 정렬"
    ],
    "answer": "2",
    "explanation": "유니온파인드(Union-Find, Disjoint Set)는 서로소 집합을 관리하는 자료구조입니다. find는 루트를 찾고(경로 압축 최적화 포함), union은 두 집합을 합칩니다. 크루스칼 MST, 사이클 판별, 연결 요소 등에 필수입니다. 거의 O(1)에 동작합니다.",
    "tags": ["유니온파인드", "서로소집합", "그래프"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 3,
    "question": "모든 정점 쌍 간의 최단 거리를 구하는 알고리즘은?",
    "options": [
      "다익스트라 알고리즘",
      "벨만-포드 알고리즘",
      "플로이드-워셜 알고리즘",
      "크루스칼 알고리즘"
    ],
    "answer": "2",
    "explanation": "플로이드-워셜은 O(V³)으로 모든 정점 쌍의 최단 거리를 구합니다. 3중 반복문으로 경유지를 하나씩 추가하며 갱신합니다. 다익스트라는 단일 출발점, 벨만-포드도 단일 출발점(음수 가중치 허용), 크루스칼은 MST 알고리즘입니다.",
    "tags": ["플로이드워셜", "최단거리", "DP"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "ox",
    "difficulty": 2,
    "question": "백트래킹은 모든 경우의 수를 탐색하되, 유망하지 않은 경로는 조기에 포기하는 기법이다.",
    "options": null,
    "answer": "true",
    "explanation": "백트래킹은 가지치기(Pruning)를 통해 불필요한 탐색을 줄입니다. 현재 선택이 해가 될 수 없다고 판단되면 즉시 이전 상태로 돌아갑니다. N-Queens, 순열/조합 생성, 스도쿠 등에 사용됩니다. 완전탐색보다 효율적입니다.",
    "tags": ["백트래킹", "가지치기", "완전탐색"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 3,
    "question": "다음 코드의 출력 결과 개수는?",
    "code_snippet": "function permutation(arr, n, current = []) {\n  if (current.length === n) {\n    console.log(current);\n    return;\n  }\n  for (const num of arr) {\n    if (!current.includes(num)) {\n      permutation(arr, n, [...current, num]);\n    }\n  }\n}\n\npermutation([1, 2, 3], 2, []);",
    "options": [
      "3개",
      "6개",
      "8개",
      "9개"
    ],
    "answer": "1",
    "explanation": "3개 중 2개를 순서대로 뽑는 순열(₃P₂ = 3 × 2 = 6)입니다. 출력: [1,2], [1,3], [2,1], [2,3], [3,1], [3,2]. 순열은 순서가 다르면 다른 경우로 취급합니다. 조합(₃C₂)이면 3개입니다. 순열/조합 구현은 코테 필수입니다.",
    "tags": ["순열", "백트래킹", "완전탐색"],
    "source": null
  }
]

[
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 1,
    "question": "BFS(너비 우선 탐색)에서 주로 사용하는 자료구조는?",
    "options": [
      "스택(Stack)",
      "큐(Queue)",
      "힙(Heap)",
      "해시맵(HashMap)"
    ],
    "answer": "1",
    "explanation": "BFS는 가까운 노드부터 탐색하므로 FIFO 구조인 큐를 사용합니다. 시작점에서 거리가 같은 노드들을 먼저 방문한 후 다음 거리의 노드들을 방문합니다. DFS는 스택(또는 재귀)을 사용합니다.",
    "tags": ["BFS", "큐", "그래프탐색"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 2,
    "question": "가중치가 없는 그래프에서 최단 거리를 구할 때 적합한 알고리즘은?",
    "options": [
      "DFS",
      "BFS",
      "다익스트라",
      "플로이드-워셜"
    ],
    "answer": "1",
    "explanation": "가중치가 없거나 모든 가중치가 동일한 그래프에서는 BFS가 최단 거리를 보장합니다. 시작점에서 거리 1인 노드 → 거리 2인 노드 순으로 탐색하기 때문입니다. 다익스트라는 가중치가 다를 때 사용합니다.",
    "tags": ["BFS", "최단거리", "그래프"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 2,
    "question": "다음 DFS 코드에서 그래프 탐색 순서로 올바른 것은? (시작: 노드 1)",
    "code_snippet": "const graph = {\n  1: [2, 3],\n  2: [4, 5],\n  3: [6],\n  4: [], 5: [], 6: []\n};\n\nfunction dfs(node, visited = new Set()) {\n  if (visited.has(node)) return;\n  console.log(node);\n  visited.add(node);\n  for (const next of graph[node]) {\n    dfs(next, visited);\n  }\n}",
    "options": [
      "1 → 2 → 3 → 4 → 5 → 6",
      "1 → 2 → 4 → 5 → 3 → 6",
      "1 → 3 → 6 → 2 → 5 → 4",
      "1 → 2 → 3 → 6 → 4 → 5"
    ],
    "answer": "1",
    "explanation": "DFS는 깊이 우선으로 탐색합니다. 1 방문 → 인접 노드 중 2 먼저 방문 → 2의 인접 노드 중 4 방문 → 4의 인접 없음, 백트래킹 → 5 방문 → 백트래킹 → 3 방문 → 6 방문. 재귀 호출 스택을 따라가면 순서를 알 수 있습니다.",
    "tags": ["DFS", "그래프탐색", "재귀"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "ox",
    "difficulty": 1,
    "question": "DFS는 재귀 함수 대신 스택을 사용하여 반복문으로도 구현할 수 있다.",
    "options": null,
    "answer": "true",
    "explanation": "재귀 호출 자체가 시스템 스택을 사용하므로, 명시적인 스택 자료구조로 대체할 수 있습니다. 재귀 깊이가 깊어 스택 오버플로우가 우려될 때 반복문 버전을 사용합니다. Python은 기본 재귀 한도가 1000이므로 주의가 필요합니다.",
    "tags": ["DFS", "스택", "재귀"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 2,
    "question": "2차원 격자에서 (0,0)에서 (n-1, m-1)까지의 최단 거리를 구할 때 BFS의 시간복잡도는?",
    "options": [
      "O(n + m)",
      "O(n × m)",
      "O(n² × m²)",
      "O(2^(n+m))"
    ],
    "answer": "1",
    "explanation": "BFS는 각 셀을 최대 한 번씩만 방문하므로 O(n × m)입니다. 2차원 격자 문제(미로 찾기, 섬의 개수 등)에서 BFS/DFS 모두 O(n × m) 시간복잡도를 가집니다. 완전탐색보다 훨씬 효율적입니다.",
    "tags": ["BFS", "2차원배열", "시간복잡도"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 2,
    "question": "동적 프로그래밍(DP)을 적용하기 위한 두 가지 조건은?",
    "options": [
      "정렬된 입력, 이진 탐색 가능",
      "최적 부분 구조, 중복되는 부분 문제",
      "그래프 구조, 사이클 없음",
      "분할 가능, 독립적인 부분 문제"
    ],
    "answer": "1",
    "explanation": "DP는 1) 최적 부분 구조(큰 문제의 최적해가 작은 문제의 최적해로 구성됨)와 2) 중복되는 부분 문제(같은 작은 문제가 여러 번 등장)를 만족할 때 적용합니다. 메모이제이션으로 중복 계산을 피해 효율성을 높입니다.",
    "tags": ["DP", "동적프로그래밍", "메모이제이션"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 2,
    "question": "다음 피보나치 함수의 시간복잡도는?",
    "code_snippet": "function fib(n, memo = {}) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];\n  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);\n  return memo[n];\n}",
    "options": [
      "O(2ⁿ)",
      "O(n²)",
      "O(n)",
      "O(log n)"
    ],
    "answer": "2",
    "explanation": "메모이제이션을 사용하면 각 fib(i)는 한 번만 계산됩니다. fib(n)부터 fib(1)까지 n개의 값만 계산하므로 O(n)입니다. 메모이제이션 없이 재귀만 사용하면 O(2ⁿ)으로 매우 비효율적입니다.",
    "tags": ["DP", "메모이제이션", "피보나치"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "multiple",
    "difficulty": 3,
    "question": "DP에서 Top-Down 방식과 Bottom-Up 방식의 차이로 올바른 것은?",
    "options": [
      "Top-Down이 항상 더 빠르다",
      "Bottom-Up은 재귀를 사용한다",
      "Top-Down은 메모이제이션, Bottom-Up은 타뷸레이션을 사용한다",
      "Bottom-Up은 메모리를 더 많이 사용한다"
    ],
    "answer": "2",
    "explanation": "Top-Down은 재귀 + 메모이제이션으로 큰 문제에서 작은 문제로 내려갑니다. Bottom-Up은 반복문 + 타뷸레이션(테이블 채우기)으로 작은 문제부터 해결합니다. Bottom-Up은 재귀 오버헤드가 없고 공간 최적화가 가능한 경우가 많습니다.",
    "tags": ["DP", "Top-Down", "Bottom-Up"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "code",
    "difficulty": 3,
    "question": "다음 DP 점화식이 해결하는 문제는?",
    "code_snippet": "// dp[i] = 인덱스 i까지의 최대 부분합\n// dp[i] = Math.max(dp[i-1] + arr[i], arr[i])\n\nfunction solution(arr) {\n  let dp = arr[0];\n  let maxSum = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    dp = Math.max(dp + arr[i], arr[i]);\n    maxSum = Math.max(maxSum, dp);\n  }\n  return maxSum;\n}",
    "options": [
      "연속된 부분 배열의 최대 합",
      "가장 긴 증가하는 부분 수열",
      "0/1 배낭 문제",
      "최장 공통 부분 수열"
    ],
    "answer": "0",
    "explanation": "카데인 알고리즘(Kadane's Algorithm)으로 연속 부분 배열의 최대 합을 O(n)에 구합니다. dp[i]는 i에서 끝나는 연속 부분 배열의 최대 합입니다. 이전까지의 합 + 현재 값 vs 현재 값부터 새로 시작 중 큰 값을 선택합니다.",
    "tags": ["DP", "카데인", "최대부분합"],
    "source": null
  },
  {
    "category": "algorithm",
    "type": "ox",
    "difficulty": 2,
    "question": "LIS(최장 증가 부분 수열) 문제는 O(n log n) 시간복잡도로 해결할 수 있다.",
    "options": null,
    "answer": "true",
    "explanation": "기본 DP로는 O(n²)이지만, 이진 탐색을 활용하면 O(n log n)으로 최적화할 수 있습니다. 각 원소마다 현재까지의 LIS 배열에서 적절한 위치를 이진 탐색으로 찾아 갱신합니다. SW 마에스트로, 빅테크 코테에서 자주 출제됩니다.",
    "tags": ["LIS", "DP", "이진탐색"],
    "source": null
  }
]

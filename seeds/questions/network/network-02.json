[
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 1,
    "question": "HTTP 상태코드 200의 의미로 올바른 것은?",
    "options": [
      "리소스가 새로 생성됨",
      "요청이 성공적으로 처리됨",
      "요청이 다른 URL로 리다이렉트됨",
      "서버 내부 오류 발생"
    ],
    "answer": "1",
    "explanation": "200 OK는 요청이 성공적으로 처리되었음을 의미합니다. 201 Created는 리소스 생성 성공, 301/302는 리다이렉트, 500은 서버 내부 오류입니다. 2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 오류, 5xx는 서버 오류를 나타냅니다.",
    "tags": ["HTTP", "상태코드", "200"],
    "source": null
  },
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 2,
    "question": "HTTP 상태코드 401과 403의 차이로 올바른 것은?",
    "options": [
      "401은 인증 실패, 403은 인증은 됐지만 권한 없음",
      "401은 권한 없음, 403은 인증 실패",
      "401은 리소스 없음, 403은 서버 오류",
      "둘 다 같은 의미로 사용됨"
    ],
    "answer": "0",
    "explanation": "401 Unauthorized는 인증이 필요하거나 인증에 실패한 경우입니다(로그인 필요). 403 Forbidden은 인증은 됐지만 해당 리소스에 대한 접근 권한이 없는 경우입니다(관리자만 접근 가능한 페이지 등). 404는 리소스를 찾을 수 없음, 500은 서버 내부 오류입니다.",
    "tags": ["HTTP", "상태코드", "인증", "권한"],
    "source": null
  },
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 2,
    "question": "HTTP 메서드 중 멱등성(Idempotent)을 가지지 않는 것은?",
    "options": [
      "GET",
      "PUT",
      "POST",
      "DELETE"
    ],
    "answer": "2",
    "explanation": "멱등성은 같은 요청을 여러 번 보내도 결과가 동일한 성질입니다. GET(조회), PUT(전체 수정), DELETE(삭제)는 멱등성을 가집니다. POST는 새 리소스를 생성하므로 여러 번 요청하면 여러 개가 생성되어 멱등성이 없습니다. PATCH는 부분 수정으로, 구현에 따라 멱등성 여부가 다를 수 있습니다.",
    "tags": ["HTTP", "메서드", "멱등성", "POST"],
    "source": null
  },
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 2,
    "question": "HTTPS가 HTTP보다 안전한 이유로 올바른 것은?",
    "options": [
      "더 빠른 속도로 데이터를 전송한다",
      "TLS/SSL을 사용하여 데이터를 암호화한다",
      "서버의 처리 능력이 향상된다",
      "더 많은 동시 연결을 지원한다"
    ],
    "answer": "1",
    "explanation": "HTTPS는 HTTP에 TLS(Transport Layer Security) 또는 SSL(Secure Sockets Layer)을 적용한 것입니다. 데이터 암호화(기밀성), 데이터 무결성, 서버 인증(신원 확인)을 제공합니다. 암호화 과정으로 인해 약간의 오버헤드가 있지만, 현대 하드웨어에서는 거의 무시할 수 있습니다. 포트 443을 기본으로 사용합니다.",
    "tags": ["HTTPS", "TLS", "SSL", "암호화"],
    "source": null
  },
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 2,
    "question": "HTTP/1.1과 HTTP/2의 차이점으로 올바른 것은?",
    "options": [
      "HTTP/2는 텍스트 기반이고, HTTP/1.1은 바이너리 기반이다",
      "HTTP/2는 멀티플렉싱을 지원하여 하나의 연결로 여러 요청을 동시 처리한다",
      "HTTP/2는 암호화를 지원하지 않는다",
      "HTTP/1.1이 HTTP/2보다 더 빠르다"
    ],
    "answer": "1",
    "explanation": "HTTP/2는 바이너리 프로토콜로, 하나의 TCP 연결에서 여러 요청/응답을 동시에 처리하는 멀티플렉싱을 지원합니다. HTTP/1.1은 텍스트 기반이고, 요청당 연결이 필요하거나 순차 처리(Head-of-Line Blocking)가 발생합니다. HTTP/2는 헤더 압축(HPACK), 서버 푸시 기능도 제공합니다.",
    "tags": ["HTTP/2", "멀티플렉싱", "성능"],
    "source": null
  },
  {
    "category": "network",
    "type": "multiple",
    "difficulty": 3,
    "question": "HTTP Keep-Alive의 역할로 올바른 것은?",
    "options": [
      "서버의 상태를 지속적으로 모니터링한다",
      "하나의 TCP 연결을 재사용하여 여러 HTTP 요청을 처리한다",
      "클라이언트의 세션을 영구적으로 유지한다",
      "HTTPS 인증서의 유효 기간을 연장한다"
    ],
    "answer": "1",
    "explanation": "HTTP/1.0은 기본적으로 요청마다 TCP 연결을 새로 맺습니다(3-way handshake 오버헤드). Keep-Alive(Persistent Connection)는 하나의 TCP 연결을 유지하여 여러 HTTP 요청/응답에 재사용합니다. HTTP/1.1은 기본으로 활성화되어 있습니다. Connection: keep-alive 헤더로 명시하거나 close로 종료할 수 있습니다.",
    "tags": ["HTTP", "Keep-Alive", "TCP연결"],
    "source": null
  },
  {
    "category": "network",
    "type": "ox",
    "difficulty": 1,
    "question": "HTTP는 상태를 유지하지 않는 Stateless 프로토콜이다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. HTTP는 각 요청이 독립적이며, 서버는 이전 요청의 정보를 기억하지 않습니다. 이를 보완하기 위해 쿠키, 세션, JWT 등을 사용하여 상태를 관리합니다. Stateless의 장점은 서버 확장이 쉽고, 각 요청을 독립적으로 처리할 수 있다는 것입니다.",
    "tags": ["HTTP", "Stateless", "상태관리"],
    "source": null
  },
  {
    "category": "network",
    "type": "ox",
    "difficulty": 2,
    "question": "HTTP 상태코드 304 Not Modified는 클라이언트의 캐시된 리소스가 여전히 유효함을 의미한다.",
    "options": null,
    "answer": "true",
    "explanation": "맞습니다. 304는 조건부 GET 요청에 대한 응답으로, 서버의 리소스가 클라이언트 캐시와 동일하여 본문을 다시 전송하지 않아도 됨을 의미합니다. If-Modified-Since, If-None-Match 헤더와 함께 사용됩니다. 네트워크 대역폭을 절약하고 응답 속도를 높입니다.",
    "tags": ["HTTP", "304", "캐시"],
    "source": null
  },
  {
    "category": "network",
    "type": "ox",
    "difficulty": 2,
    "question": "HTTP GET 요청은 요청 본문(Body)을 포함할 수 없다.",
    "options": null,
    "answer": "false",
    "explanation": "틀렸습니다. HTTP 명세상 GET 요청에 본문을 포함하는 것은 금지되지 않습니다. 하지만 대부분의 서버와 프록시가 GET 본문을 무시하거나 오류를 반환하므로, 실무에서는 사용하지 않는 것이 권장됩니다. 검색 조건 등 데이터 전달이 필요하면 쿼리 스트링을 사용하거나 POST를 고려합니다.",
    "tags": ["HTTP", "GET", "요청본문"],
    "source": null
  },
  {
    "category": "network",
    "type": "blank",
    "difficulty": 1,
    "question": "HTTP 기본 포트는 80이고, HTTPS 기본 포트는 _____이다.",
    "options": null,
    "answer": "443",
    "explanation": "HTTP는 포트 80, HTTPS는 포트 443을 기본으로 사용합니다. URL에 포트를 명시하지 않으면 프로토콜에 따라 기본 포트가 사용됩니다. 다른 대표적인 포트: FTP(21), SSH(22), SMTP(25), DNS(53), MySQL(3306), PostgreSQL(5432). Well-known 포트는 0-1023 범위입니다.",
    "tags": ["HTTP", "HTTPS", "포트"],
    "source": null
  }
]
